{
  "docstring": {
    "long_description": "The description of that function is as follows:\n\n    Singular Value Decomposition.\n\n    When 'a' is a 2D array, and \"full_matrices=False\", then it is factorized as \"u @ np.diag(s) @ vh = (u * s) @ vh\",\n    where 'u' and the Hermitian transpose of 'vh' are 2D arrays with orthonormal columns and 's' is a 1D array of 'a' singular values.\n\n    When 'a' is higher-dimensional, SVD is applied in stacked mode as explained below.",
    "short_description": "The SVD node is based on a numpy or scipy function.",
    "parameters": [
      {
        "name": "select_return",
        "type": "'u', 's', 'vh'",
        "description": "Select the desired object to return.\nSee the respective function docs for descriptors."
      },
      {
        "name": "a",
        "type": "(..., M, N) array_like",
        "description": "A real or complex array with \"a.ndim >= 2\"."
      },
      {
        "name": "full_matrices",
        "type": "bool",
        "description": "If True (default), 'u' and 'vh' have the shapes \"(..., M, M)\" and \"(..., N, N)\", respectively.\nOtherwise, the shapes are \"(..., M, K)\" and \"(..., K, N)\", respectively, where \"K = min(M, N)\"."
      },
      {
        "name": "compute_uv",
        "type": "bool",
        "description": "Whether or not to compute 'u' and 'vh' in addition to 's'.\nTrue by default."
      },
      {
        "name": "hermitian",
        "type": "bool",
        "description": "If True, 'a' is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values.\nDefaults to False."
      },
      {
        "name": ".. versionadded",
        "type": ": 1.17.0",
        "description": null
      }
    ],
    "returns": [
      {
        "name": null,
        "type": "DataContainer",
        "description": "type 'ordered pair', 'scalar', or 'matrix'"
      }
    ]
  }
}