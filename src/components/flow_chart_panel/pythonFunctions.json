{"GENERATOR": {"CONSTANT.py": "import numpy as np\nfrom .VCTR import fetch_inputs\n\ndef CONSTANT(**kwargs):\n    print('running constant in python program...',)\n    # ''' Generates a single x-y vector of numeric (floating point) constants'''\n    params = {\n        'constant': 2\n    }\n    previous_job_results = list()\n\n    if 'previous_job_ids' in kwargs:\n        previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    \n    if 'ctrls' in kwargs:\n        ctrls = kwargs['ctrls']\n    for key, input in ctrls.items():\n        paramName = input['param']\n        if paramName in params:\n                params[paramName] = input['value']\n    if previous_job_results.__len__() > 0:\n        xy0 = previous_job_results[0]\n        x = xy0['x0']\n        y = np.full(len(x), float(params['constant']))\n        return {'x0':x, 'y0':y}\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params['constant']))\n    return {'x0': x,'y0':y}\n", "LINSPACE.py": "import numpy as np\nimport traceback\nfrom .VCTR import fetch_inputs\n\n\ndef LINSPACE(**kwargs):\n    params = {\n        'start': 10,\n        'end': 0,\n        'steps': 1000,\n    }\n    if 'ctrls' in kwargs:\n        ctrls = kwargs['ctrls']\n        for key, input in ctrls.items():\n            paramName = input['param']\n            if paramName in params:\n                params[paramName] = input['value']\n\n        x = np.linspace(params['start'], params['end'], params['steps'])\n\n    return {'x0': x}\n  \n        # if 'ctrls' not in kwargs:\n        #     ctrls = dict(start=-10, end=10, steps=1000)\n        # elif 'start' not in kwargs['ctrls'].keys():\n        #     ctrls = dict(start=-10, end=10, steps=1000)\n        # else:\n        #     ctrls = kwargs['ctrls']\n    # except Exception:\n    #     print(traceback.format_exc())", "RAND.py": "import numpy as np\nfrom .VCTR import fetch_inputs\nimport json\nimport traceback\n\ndef RAND(**kwargs):\n    try:\n        print('~ RAND ~')\n        print(json.dumps(kwargs))\n        print('PID', kwargs['previous_job_ids'])\n\n        previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n\n        xy0 = previous_job_results[0]\n\n        x = xy0['x0']\n\n        y = np.random.normal(size=len(x))\n    except Exception:\n        print(traceback.format_exc())\n    \n    return {'x0':x, 'y0':y}\n", "SINE.py": "import numpy as np\nfrom .VCTR import fetch_inputs\nfrom scipy import signal\n\ndef SINE(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n\n    params = {\n        'frequency': 3.14,\n        'offset': 0,\n        'amplitude': 1,\n        'waveform': 'sine'\n    }\n\n    if 'ctrls' in kwargs:\n        ctrls = kwargs['ctrls']\n        for key, input in ctrls.items():\n            paramName = input['param']\n            if paramName in params:\n                params[paramName] = input['value']\n\n    print('params sine:', params)\n\n    xy0 = previous_job_results[0]\n    x = xy0['x0']\n\n    waveform = params['waveform']\n    A = params['amplitude']\n    F = params['frequency']\n    Y0 = params['offset']\n\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print('invalid waveform passed as param, using default:', waveform)\n\n    print('A:', A)\n    print('F:', F)\n    print('Y0:', Y0)\n\n    if waveform == 'sine':\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x)\n    elif waveform == 'square':\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10)\n    elif waveform == 'triangle':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10, 0.5)\n    elif waveform == 'sawtooth':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x)\n\n    print('finished sine')\n    return {'x0':x, 'y0':y}\n"}, "TRANSFORMER": {"ADD.py": "import numpy as np\nfrom .VCTR import fetch_inputs\n\ndef ADD(**kwargs):\n    ''' Add 2 input vectors and return the result '''\n    y2 = [0]\n    \n\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n\n    x = previous_job_results[0]['x0']\n    if len(previous_job_results) == 2:\n        y2 = previous_job_results[1]['y0']\n    y = np.add(\n        previous_job_results[0]['y0'], \n        y2)\n    return {'x0':x, 'y0':y}", "MULTIPLY.py": "import numpy as np\nfrom .VCTR import fetch_inputs\n\ndef MULTIPLY(**kwargs):\n    ''' Takes 2 input vectors, multiplies them, and returns the result '''\n\n    print('MULTIPLY started with kwards', kwargs)\n\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n\n    x = previous_job_results[0]['x0']\n\n    y = np.multiply(\n        previous_job_results[0]['y0'], \n        previous_job_results[1]['y0'])\n\n    return {'x0':x, 'y0':y}"}, "VISOR": {"BAR.py": "from .VCTR import fetch_inputs\nfrom .template import init_template\n\ndef BAR(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    payload = previous_job_results[0]\n\n    fig = dict(\n        data = [dict(\n            x = list(payload['x0']),\n            y = list(payload['y0']),\n            type='bar'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "HISTOGRAM.py": "from .VCTR import fetch_inputs\nfrom .template import init_template\n\ndef HISTOGRAM(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    payload = previous_job_results[0]\n\n    fig = dict(\n        data = [dict(\n            x = list(payload['x0']),\n            type='histogram',\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "LINE.py": "from .VCTR import fetch_inputs\nfrom .template import init_template\n\ndef LINE(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    payload = previous_job_results[0]\n\n    fig = dict(\n        data = [dict(\n            x = list(payload['x0']),\n            y = list(payload['y0']),\n            type='scatter',\n            mode='lines'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "SCATTER.py": "from .VCTR import fetch_inputs\nfrom .template import init_template\n\ndef SCATTER(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    payload = previous_job_results[0]\n\n    fig = dict(\n        data = [dict(\n            x = list(payload['x0']),\n            y = list(payload['y0']),\n            type='scatter',\n            mode='markers'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "SCATTER3D.py": "from .VCTR import fetch_inputs\nfrom .template import init_template\n\ndef SCATTER3D(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    payload = previous_job_results[0]\n\n    fig = dict(\n        data = [dict(\n            x = list(payload['x0']),\n            y = list(payload['y0']),\n            z = list(payload['z0']) if 'z0' in payload else list([0] * len(payload['x0'])),\n            type='scatter3d',\n            mode='markers'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "SURFACE3D.py": "from .VCTR import fetch_inputs\nfrom .template import init_template\n\ndef SURFACE3D(**kwargs):\n    previous_job_results = fetch_inputs(kwargs['previous_job_ids'])\n    payload = previous_job_results[0]\n\n    fig = dict(\n        data = [dict(\n            x = list(payload['x0']),\n            y = list(payload['y0']),\n            z = list(payload['z0']) if 'z0' in payload else list([0] * len(payload['y0'])),\n            type='surface'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "template.py": "import plotly.graph_objects as go\n\ndef init_template():\n    \n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n\n"}}