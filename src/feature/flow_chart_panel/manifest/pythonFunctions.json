{
  "SECOND_ORDER_SYSTEM.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = \"SECOND_ORDER_SYSTEM\"\n\n\n@flojoy\ndef SECOND_ORDER_SYSTEM(v, params):\n    # Let's first define things that won't change over\n    # each iteration: time constants, etc ...\n    d1 = float(params[\"d1\"])  # first time constant in us, 250\n    d2 = float(params[\"d2\"])  # second time constant in us, 100\n    node_id = params.get(\"node_id\", 0)\n\n    # ... and now some helper functions\n    x1 = np.exp(-1.0 / d1) if d1 > 0 else 0.0\n    x2 = np.exp(-1.0 / d2) if d2 > 0 else 0.0\n    ac = (1.0 - x1) * (1.0 - x2)\n    bpd = x1 + x2\n    bd = x1 * x2\n\n    # Now we require memory. The only thing we need in memory is the last two\n    # values the system had in this basic example.\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Error loading object from REDIS.\")\n\n    # We're going to store and read the data in reverse order to\n    # how it is accessed here. We will write the functionality\n    # below to assume the most recent time step is the first\n    # index. However, for visualization and external access,\n    # it makes the most sense to have the first time step\n    # as the first index!\n    y_primes = np.zeros((2, 1)) if initialize else data[::-1]\n\n    # Using input from controller as v[0].y ...\n    response = ac * v[0].y[-1] + bpd * y_primes[0] - bd * y_primes[1]\n    y_primes[1] = y_primes[0]\n\n    # prepend the most recent result to the front of the histrory\n    y_primes = np.insert(y_primes, 0, response)\n    # We now write to memory, reversing the order ...\n    SmallMemory().write_to_memory(node_id, memory_key, y_primes[::-1])\n    # ... and return the result!\n    return DataContainer(\n        x=v[0].y, y=np.ones_like(v[0].y) * float(y_primes[0])\n    )  # returns input output pair\n",
  "FEEDBACK.py": "from flojoy import flojoy, DataContainer, get_job_result\nfrom rq.job import NoSuchJobError\nimport traceback\n\n\n@flojoy\ndef FEEDBACK(v, params):\n    referred_node = params[\"referred_node\"]\n\n    try:\n        result = get_job_result(referred_node)\n        return result\n    except (Exception, NoSuchJobError) as e:\n        x = v[0].x\n        y = v[0].y\n        print(\"Job not found: \", e, traceback.format_exc())\n        return DataContainer(x=x, y=y)\n",
  "CONSTANT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef CONSTANT(v, params):\n    \"\"\"Generates a single x-y vector of numeric (floating point) constants\"\"\"\n\n    if v.__len__() > 0:\n        x = v[0].y\n        y = np.full(len(x), float(params[\"constant\"]))\n        return DataContainer(x=x, y=y)\n\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params[\"constant\"]))\n\n    return DataContainer(x=x, y=y)\n",
  "SINE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom scipy import signal\n\n\n@flojoy\ndef SINE(v, params):\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n\n    waveform = params[\"waveform\"]\n    A = float(params[\"amplitude\"])\n    F = float(params[\"frequency\"])\n    Y0 = float(params[\"offset\"])\n    PHASE = float(params[\"phase\"])\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print(\"invalid waveform passed as param, using default:\", waveform)\n\n    if waveform == \"sine\":\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x + np.radians(PHASE))\n    elif waveform == \"square\":\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10 + np.radians(PHASE))\n    elif waveform == \"triangle\":\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10 + np.radians(PHASE), 0.5)\n    elif waveform == \"sawtooth\":\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x + np.radians(PHASE))\n\n    return DataContainer(x=x, y=y)\n",
  "TIMESERIES.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport pandas.testing as testing\nimport traceback\n\n\n@flojoy\ndef TIMESERIES(v, params):\n    \"\"\"\n    Generates a random timeseries vector\n    \"\"\"\n\n    try:\n        np.random.seed(1)\n        testing.N, testing.K = 1000, 1  # rows, columns\n        df = testing.makeTimeDataFrame(freq=\"MS\")\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(x=df.index.to_numpy(), y=df[\"A\"].to_numpy())\n",
  "RAND.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport traceback\n\n\n@flojoy\ndef RAND(v, params):\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = np.random.normal(size=len(x))\n    else:\n        y = np.random.normal(size=1000)\n\n    return DataContainer(x=x, y=y)\n\n\n@flojoy\ndef RAND_MOCK(v, params):\n    print(\"running mock version of rand\")\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = x\n    else:\n        y = np.full(\n            1000, 1000\n        )  # for reproducibility returning an array with constant values\n    return DataContainer(x=x, y=y)\n",
  "LINSPACE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef LINSPACE(v, params):\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n    y = np.linspace(float(params[\"start\"]), float(params[\"end\"]), int(params[\"step\"]))\n    result = DataContainer(x=x, y=y)\n    return result\n",
  "template.py": "import plotly.graph_objects as go\n\n\ndef init_template():\n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n",
  "HISTOGRAM.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\n\n\n@flojoy\ndef HISTOGRAM(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_pair\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError(\"unsupported type for HISTOGRAM  node\")\n    fig = px.histogram(x=x, y=y)\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y)\n",
  "SCATTER.py": "import plotly.graph_objects as go\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef SCATTER(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_pair\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError(\"unsupported input type for SCATTER node\")\n    fig = go.Figure(data=go.Scatter(x=x, y=y, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y)\n",
  "LINE.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\n\n\n@flojoy\ndef LINE(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_pair\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError(\"unsupported input type for LINE node\")\n    fig = go.Figure(data=go.Line(x=x, y=y, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y)\n",
  "BAR.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\n\n\n@flojoy\ndef BAR(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_pair\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError(\"unsupported input type for BAR node\")\n    fig = px.scatter(x=x, y=y, mode=\"markers\")\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y)\n",
  "SCATTER3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SCATTER3D(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_triple\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError(\"unsupported input type for SCATTER3D node\")\n    fig = go.Figure(data=go.Scatter3d(x=x, y=y, z=z, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y, z=z)\n",
  "SURFACE3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SURFACE3D(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_triple\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError(\"unsupported input type for SURFACE3D node\")\n    fig = go.Figure(data=go.Surface(x=x, y=y, z=z, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y, z=z)\n",
  "IMAGE.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\nimport numpy as np\n\n\n@flojoy\ndef IMAGE(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"image\":\n        r = dc_input.r\n        g = dc_input.g\n        b = dc_input.b\n        a = dc_input.a\n    else:\n        raise ValueError(\"unsupported input type for IMAGE node\")\n    if a is None:\n        img_combined = np.stack((r, g, b), axis=2)\n    else:\n        img_combined = np.stack((r, g, b, a), axis=2)\n    fig = px.imshow(img=img_combined)\n\n    return DataContainer(type=\"plotly\", fig=fig, r=r, g=g, b=b, a=a)\n",
  "PHIDGET22.py": "from flojoy import flojoy, DataContainer\nimport Phidget22\nfrom Phidget22.Phidget import *\nfrom Phidget22.Devices.VoltageRatioInput import *\n\n\ndef onVoltageRatioChange(self, voltageRatio):\n    print(\n        \"VoltageRatio [\" + str(self.getChannel()) + \"]: \" + str(voltageRatio)\n    )  # Declaration of the Event handler, Voltage changement\n\n\n@flojoy\ndef PHIDGET22(dc, params):\n    voltage = []\n    pressions = []\n    N = int(params[\"n_sensors\"])\n\n    for i in range(0, N):\n        voltageRatioInput = (\n            VoltageRatioInput()\n        )  # Creation of an instance of the VoltageRationInput class\n        voltageRatioInput.setChannel(\n            i\n        )  # Set Channel for Communication with the Phidget Interface Kit\n        voltageRatioInput.setOnVoltageRatioChangeHandler(\n            onVoltageRatioChange\n        )  # Assign the handler that will be called when the event occurs\n        voltageRatioInput.openWaitForAttachment(\n            5000\n        )  # Open the Channel after event handler is set\n        volt_i = voltageRatioInput.getVoltageRatio()  # Measure Voltage from the sensor\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n\n        pression_i = (\n            volt_i - 0.015\n        ) / 0.06  # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n\n\n@flojoy\ndef PHIDGET22_MOCK(dc, params):\n    print(\n        \"running mock version of PHIDGET SENSOR, number of sensor is set to 4 by default\"\n    )\n\n    voltage = []\n    pressions = []\n    N = 4\n\n    for i in range(0, N):\n        volt_i = i * 10 + 4  # Scalar operation to modify data\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n        pression_i = (\n            volt_i - 0.015\n        ) / 0.06  # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n",
  "KEITHLEY2400.py": "import numpy as np\nimport serial\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef KEITHLEY2400(dc, params):  # params {comport, baudrate,timeout}\n    # Serial communication with the instrument configuration\n    ser = serial.Serial()\n\n    # Specific parameters\n\n    ser.port = params[\"comport\"]  # Secify serial port for com\n    ser.baudrate = params[\"baudrate\"]  # Specify Baudrate\n\n    # General parameters\n    ser.bytesize = serial.EIGHTBITS  # Specify Bites number\n    ser.parity = serial.PARITY_NONE  # Specify Parity\n    ser.stopbits = serial.STOPBITS_ONE  # Specify Stop bites\n    ser.timeout = 1\n    # Open Serial Com\n    ser.open()\n\n    # Keithley 2400 Configuration\n    ser.write(b\"*RST\\n\")  # reinitialisation of the instrument\n    ser.write(b\":SOUR:FUNC:MODE VOLT\\n\")  # Sourcing tension\n    ser.write(b':SENS:FUNC \"CURR\"\\n')  # Measuring current\n    ser.write(\n        b\":SENS:CURR:PROT 1.05\\n\"\n    )  # Current protection set at 1.05A : Maximum for keithely 2400\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        ser.write(b\":SOUR:VOLT %f\\n\" % voltage)  # Source Tension (V)\n        ser.write(b\":OUTP ON\\n\")  # Instrument output open\n        ser.write(b\":INIT\\n\")  # Start measuring\n        ser.write(b\":FETC?\\n\")  # Retrieve the measured values\n\n        current_str = ser.readline().decode(\"ascii\").strip()  # Save answers in a string\n        voltage_current_values = current_str.split(\n            \",\"\n        )  # Split the string into measured values (Voltage, Current, Etc)\n        currents_neg.append(\n            -float(voltage_current_values[1])\n        )  # Converts measured currents into float\n\n        ser.write(b\":OUTP OFF\\n\")  # Close output from Instrument\n\n    # Close Serial Communication\n\n    ser.close()\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n\n\n@flojoy\ndef KEITHLEY2400_MOCK(dc, params):  # params {comport, baudrate,timeout}\n    print(\"Running mock version of Keithley2400\")\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        voltage_current_values = (\n            voltages * 0.15\n        )  # Apply a scalar operation on the mock Voltage\n        currents_neg.append(\n            -float(voltage_current_values[1])\n        )  # Converts measured currents into float\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n",
  "LABJACKU3.py": "from flojoy import flojoy, DataContainer\n\nimport u3  # Import the library from LabJackPython in order to use our U3-LV device\n\n\n@flojoy\ndef LABJACKU3(dc, params):  # params {nombre de sensor}\n    d = u3.U3()  # Create an instance of U3 class d.configU3()\n    d.configIO(\n        FIOAnalog=255, EIOAnalog=0\n    )  # Config the U3 for daq from temperature sensors\n\n    voltages = []  # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = int(params[\"numbers\"])\n\n    for i in range(1, N):  # Loop on the number of sensor you are using\n        voltage = d.getAIN(i - 1)\n        temperature = voltage * 100.0\n        temperature_celcius = (\n            temperature - 32\n        ) / 1.8  # Convert Voltage into temperature in Celcius\n\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n    return DataContainer(\n        x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius\n    )\n\n\n@flojoy\ndef LABJACKU3_MOCK(dc, params):  # params {nombre de sensor}\n    print(\"running mock version of LabJackU3, number of sensor is set to 6 by default\")\n\n    voltages = []  # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = 6  # Mock Number of sensors\n\n    for i in range(1, N):  # Loop on the number of sensor you are using\n        voltage = 0.6  # Mock Value for the measured voltage\n        temperature = voltage * 100.0\n        temperature_celcius = (\n            temperature - 32\n        ) / 1.8  # Convert Voltage into temperature in Celcius\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n\n    return DataContainer(\n        x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius\n    )\n",
  "CAMERA.py": "import cv2\nimport os\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef CAMERA(v, params):\n    \"\"\"\n    Take a picture from a connected camera using OpenCV.\n    If no camera is connected, this will load the example image: \"object_detection.png\".\n    Perhaps after testing is finished, an error should be thrown if no camera was detected.\n    \"\"\"\n    print(\"parameters passed to CAMERA: \", params)\n    y = {}\n    camera_test = False  # Value to test if image is the default image.\n\n    try:\n        camera_index = int(params.get(\"camera_ind\", -1))\n        camera = cv2.VideoCapture(\n            camera_index\n        )  # Camera indicator for selection of specific camera\n        test = camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n        # print('\\n', test, '\\n')  # Print to check if setting the resolution worked.\n        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)\n\n        (\n            return_value,\n            image,\n        ) = camera.read()  # Read camera. Return value can be useful for testing.\n        if image is None:\n            raise cv2.error\n\n        # print(image.shape)\n        camera_test = True  # Camera has been detected.\n        camera.release()  # Release the camera for further use.\n        del camera\n\n    except (\n        cv2.error\n    ) as camera_error:  # Catch error for when a camera isn't detected. Should it throw an error for production?\n        pass\n\n    if not camera_test:\n        print(\"OpenCV cannot read the specified camera.\")\n        print(\"Loading backup image.\")\n        filePath = \"../public/assets/object_detection.png\"  # Load example image instead for testing.\n        # Load the file and put into bytearray.\n        print(\"File to be loaded: \" + filePath)\n        with open(filePath, \"rb\") as fileToBeLoaded:\n            f = fileToBeLoaded.read()\n            # print(type(cv2.imread(filePath)))\n            y = [bytearray(f)]\n            # print(type(f))\n            # print(type(bytearray(f)))\n        fileToBeLoaded.close()\n\n    else:\n        f = cv2.imencode(\".png\", image)[1]  # encode image to pass to next node.\n        y = [bytearray(f)]\n\n    return DataContainer(type=\"file\", y=y, file_type=[\"image\"])\n",
  "SUBTRACT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef SUBTRACT(v, params):\n    \"\"\"Subtract 2 input vectors and return the result\"\"\"\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1][\"y\"]\n\n    y = np.subtract(a, b)\n\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "ADD.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef ADD(v, params):\n    \"\"\"Add 2 input vectors and return the result\"\"\"\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1][\"y\"]\n\n    y = np.add(a, b)\n\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "MULTIPLY.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MULTIPLY(v, params):\n    \"\"\"Takes 2 input vectors, multiplies them, and returns the result\"\"\"\n    a = v[0].y\n    b = v[1].y\n    y = np.multiply(a, b)\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "ABS.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef ABS(v, params):\n    \"\"\"Returns abolute value\"\"\"\n    return DataContainer(x=v[0].y, y=np.abs(v[0].y))\n",
  "BUTTER.py": "from scipy import signal\nimport numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef BUTTER(v, params):\n    \"\"\"Apply a butterworth filter to an input vector\"\"\"\n\n    print(\"Butterworth inputs:\", v)\n\n    sig = v[0].y\n\n    sos = signal.butter(10, 15, \"hp\", fs=1000, output=\"sos\")\n    filtered = signal.sosfilt(sos, sig)\n\n    return DataContainer(x=sig, y=filtered)\n",
  "SAVGOL.py": "import scipy\nfrom flojoy import flojoy, DataContainer\nimport warnings\n\n\n@flojoy\ndef SAVGOL(v, params):\n    \"\"\"Apply a Savitzky-Golay filter to an input vector.\n    The default behaviour is implementing a 3-point moving average of the data.\"\"\"\n    print(\"Savgol inputs:\", v)\n    signal = v[0].y\n    window_length = int(params[\"wlen\"])\n    poly_order = int(params[\"porder\"])\n    if poly_order >= window_length:\n        warnings.warn(\n            \"Polynomial order is greater than the window size. Using p=w-1...\"\n        )\n        poly_order = window_length - 1\n    filtered = scipy.signal.savgol_filter(signal, window_length, poly_order)\n    return DataContainer(x=signal, y=filtered)\n",
  "FIR.py": "from scipy import signal\nfrom flojoy import flojoy, DataContainer\nimport numpy as np\n\n\n@flojoy\ndef FIR(v, params):\n    \"\"\"Apply a low-pass FIR filter to an input vector. This\n    filter takes a few inputs: the sample_rate (will be passed as a parameter\n    if the target node is not connected), the desired width of the\n    transition to the stop band and the corresponding attentuation, and\n    lastly the cutoff frequency.\"\"\"\n\n    sample_rate = float(params[\"sample_rate\"])  # Hz\n    transition_width = float(params[\"transition_width\"])  # Hz\n    stop_band_attenuation = float(params[\"stop_band_attenuation\"])  # dB\n    cutoff_freq = float(params[\"cutoff_freq\"])  # Hz\n    print(\n        f\"FIR params: {[sample_rate,transition_width,stop_band_attenuation,cutoff_freq]}\"\n    )\n\n    try:\n        times = v[1].y  # v[0].x['i']\n        x = v[0].y  # this is the value of the signal\n    except IndexError:  # nothing input\n        # lets create some default behaviour for testing\n        nsamples = 400\n        times = np.arange(nsamples) / sample_rate\n        test_x = (\n            np.cos(2 * np.pi * 0.5 * times)\n            + 0.2 * np.sin(2 * np.pi * 2.5 * times + 0.1)\n            + 0.2 * np.sin(2 * np.pi * 15.3 * times)\n            + 0.1 * np.sin(2 * np.pi * 16.7 * times + 0.1)\n            + 0.1 * np.sin(2 * np.pi * 23.45 * times + 0.8)\n        )\n        x = test_x\n\n    # first we need to define the nyquist rate ...\n    nyq_rate = sample_rate / 2.0\n    # ... then the transition width relative to this\n    transition_width /= nyq_rate\n\n    # Now compute order and Kaiser param for the fitler\n    N, beta = signal.kaiserord(stop_band_attenuation, transition_width)\n\n    # Now we create the filter with the Kaiser window ...\n    taps = signal.firwin(N, cutoff_freq / nyq_rate, window=(\"kaiser\", beta))\n\n    # ... and then apply it to the signal\n    filtered_x = signal.lfilter(taps, 1.0, x)\n\n    # Now, there are two considerations to be had. Firstly,\n    # there is a phase delay in the signal since we have applied finite\n    # taps ...\n    phase_delay = 0.5 * (N - 1) / sample_rate\n    # ... and furthermore, the first N-1 samples are 'corrupted' in\n    # the sense that the filter 'sacrifies' them by the imposition\n    # of the initial conditions.\n    times = times[N - 1 :] - phase_delay\n    filtered_x = filtered_x[N - 1 :]\n\n    return DataContainer(x=times, y=filtered_x)\n",
  "PID.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = \"pid-info\"\n\n\n@flojoy\ndef PID(v, params):\n    # First let's get the parameters that won't change\n    Kp = float(params[\"Kp\"])\n    Ki = float(params[\"Ki\"])\n    Kd = float(params[\"Kd\"])\n    node_id = params.get(\"node_id\", 0)\n    # Now we need some memory! We need to keep track of the running\n    # integral value of the inputs (regulation errors), as well as\n    # the previous 3 values of the regulation error\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Issue reading memory from REDIS.\")\n    integral = 0 if initialize else data[0]\n    regulation_error_primes = np.zeros((3, 1)) if initialize else data[1:]\n    print(f\"Recovered data: {data}\")\n\n    regulation_error = v[0].y[\n        -1\n    ]  # constant node makes long list of items; just need the value so take last element\n    integral += 0.5 * Ki * (regulation_error + regulation_error_primes[0])\n    output_signal = (\n        Kp * regulation_error\n        + integral\n        + 0.1667\n        * Kd\n        * (\n            regulation_error\n            - regulation_error_primes[2]\n            + 3.0 * (regulation_error_primes[0] - regulation_error_primes[1])\n        )\n    )\n    regulation_error_primes[2] = regulation_error_primes[1]\n    regulation_error_primes[1] = regulation_error_primes[0]\n    regulation_error_primes[0] = regulation_error\n\n    # Now write to memory ...\n    SmallMemory().write_to_memory(\n        node_id, memory_key, np.append(integral, regulation_error_primes)\n    )\n    print(regulation_error, output_signal)\n    # ... and return the result\n    return DataContainer(x=v[0].y, y=np.ones_like(v[0].y) * output_signal)\n",
  "INVERT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef INVERT(v, params):\n    \"\"\"Takes 2 inputs, one matrix and one rcond if not square matrix.\n    Inverts them (or pseudo invert) and returns the result.\n    If the entered value is a scalar it returns the multiplciative\n    inverse 1/x\"\"\"\n    print(f\"INVERT params: {params}\")\n    a = np.eye(3)\n    b = float(params[\"rcond\"])\n\n    if v.__len__ > 0:\n        if (\n            v[0].type == \"ordered_pair\"\n        ):  # v[0] is a DataContainer object with type attribute\n            print(\"Performing simple inversion\")\n            a = v[0].y  # scalar valued\n            return DataContainer(x=a, y=1 / a)\n        elif v[0].type == \"matrix\":\n            a = v[0].m\n            if not a.shape[0] == a.shape[1]:\n                print(\"Not square matrix! Using pseudoinversion...\")\n                assert (\n                    type(b) == float\n                ), \"Need scalar value to compare SVDs for pseudoinversion\"\n                retval = np.linalg.pinv(a, rcond=b, hermitian=False)\n            else:\n                try:\n                    retval = np.linalg.inv(a)\n                except np.linalg.LinAlgError:\n                    raise ValueError(\"Inversion failed! Singular matrix returned...\")\n            return DataContainer(type=\"matrix\", m=retval)\n        else:\n            raise ValueError(\"Incorrect input DataContainer type.\")\n    else:\n        return DataContainer(type=\"matrix\", m=np.eye(3))\n",
  "MATMUL.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MATMUL(v, params):\n    \"\"\"Takes 2 input matrices, multiplies them, and returns the result\"\"\"\n    a = np.eye(3)\n    b = np.eye(3)\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1][\"y\"]\n    return DataContainer(type=\"matrix\", m=np.matmul(a, b))\n",
  "LOCAL_FILE.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\nfrom PIL import Image\nfrom os import path\n\n\n@flojoy\ndef LOCAL_FILE(v, params):\n    print(\"parameters passed to LOCAL_FILE: \", params)\n    file_type = params.get(\"file_type\", \"image\")\n    match file_type:\n        case \"image\":\n            red_channel = []\n            green_channel = []\n            blue_channel = []\n            alpha_channel = []\n            try:\n                filePath = \"\"\n                ctrlInput = params[\"path\"]\n                opType = params[\"op_type\"]\n                if ctrlInput is not None and len(ctrlInput.strip()) > 0:\n                    filePath = ctrlInput\n                elif len(filePath.strip()) == 0:\n                    if opType == \"OD\":\n                        filePath = path.join(\n                            path.dirname(path.abspath(__file__)),\n                            \"assets\",\n                            \"object_detection.png\",\n                        )\n                print(\"File to be loaded: \" + filePath)\n                f = Image.open(filePath)\n                img_array = np.array(f.convert(\"RGBA\"))\n                if img_array.shape[2] == 4:\n                    red_channel = img_array[:, :, 0]\n                    green_channel = img_array[:, :, 1]\n                    blue_channel = img_array[:, :, 2]\n                    alpha_channel = img_array[:, :, 3]\n                else:\n                    red_channel = img_array[:, :, 0]\n                    green_channel = img_array[:, :, 1]\n                    blue_channel = img_array[:, :, 2]\n                    alpha_channel = None\n            except Exception:\n                print(traceback.format_exc())\n            return DataContainer(\n                type=\"image\",\n                r=red_channel,\n                g=green_channel,\n                b=blue_channel,\n                a=alpha_channel,\n            )\n        case _:\n            return JobResultBuilder().from_inputs(v).build()\n",
  "LOADER.py": "import json\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport requests\nimport yaml\nfrom flojoy import DataContainer, flojoy\nfrom flojoy.utils import PlotlyJSONEncoder\n\nFRONTIER_HOST = os.environ.get(\"FRONTIER_HOST\")\nFORNTIER_PORT = os.environ.get(\"FRONTIER_PORT\")\nAPI_URI = f\"https://{FRONTIER_HOST}:{FORNTIER_PORT}/measurements\"\n\n\n@flojoy\ndef LOADER(dc_inputs: list[DataContainer], params: dict):\n    api_key = get_api_key()\n    measurement_uuid = params[\"measurement_uuid\"]\n\n    if api_key != \"\" and measurement_uuid != \"\":\n        try:\n            requests.post(\n                f\"{API_URI}/{measurement_uuid}\",\n                json={\n                    \"api_key\": api_key,\n                    \"measurements\": json.dumps(\n                        {\"data\": dc_inputs[0]}, cls=PlotlyJSONEncoder\n                    ),\n                    \"time\": datetime.now().__str__(),\n                },\n            )\n        except Exception as e:\n            raise e\n        return dc_inputs[0]\n    else:\n        not_found_key = \"FRONTIER_API_KEY\" if api_key == \"\" else \"Measurement UUID\"\n        raise KeyError(f\"{not_found_key} not found!\")\n\n\ndef get_api_key():\n    home = str(Path.home())\n    api_key = \"\"\n    path = os.path.join(home, \".flojoy/credentials\")\n    if not os.path.exists(path):\n        return api_key\n\n    stream = open(path, \"r\", encoding=\"utf-8\")\n    yaml_dict = yaml.load(stream, Loader=yaml.FullLoader)\n    if yaml_dict is None:\n        return api_key\n    if isinstance(yaml_dict, str) == True:\n        split_by_line = yaml_dict.split(\"\\n\")\n        for line in split_by_line:\n            if \"FRONTIER_API_KEY\" in line:\n                api_key = line.split(\":\")[1]\n    else:\n        api_key = yaml_dict.get(\"FRONTIER_API_KEY\", \"\")\n    return api_key\n",
  "OBJECT_DETECTION.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\n\nfrom utils.object_detection.object_detection import detect_object\n\n\n@flojoy\ndef OBJECT_DETECTION(v, params):\n    try:\n        red_channel = []\n        green_channel = []\n        blue_channel = []\n        alpha_channel = []\n        print(\"Detecting objects...\")\n        r = v[0].r\n        g = v[0].g\n        b = v[0].b\n        a = v[0].a\n        print(\" a here: \", a)\n        if a is not None:\n            nparr = np.stack((r, g, b, a), axis=2)\n        else:\n            nparr = np.stack((r, g, b), axis=2)\n        img_array = detect_object(nparr)\n        if img_array.shape[2] == 4:\n            red_channel = img_array[:, :, 0]\n            green_channel = img_array[:, :, 1]\n            blue_channel = img_array[:, :, 2]\n            alpha_channel = img_array[:, :, 3]\n        else:\n            red_channel = img_array[:, :, 0]\n            green_channel = img_array[:, :, 1]\n            blue_channel = img_array[:, :, 2]\n            alpha_channel = None\n        return DataContainer(\n            type=\"image\",\n            r=red_channel,\n            g=green_channel,\n            b=blue_channel,\n            a=alpha_channel,\n        )\n\n    except Exception:\n        print(traceback.format_exc())\n        raise\n",
  "END.py": "from flojoy import flojoy, JobResultBuilder\n\n\n@flojoy\ndef END(v, params):\n    inputs = v if len(v) > 0 else []\n    return JobResultBuilder().from_inputs(inputs).flow_to_nodes([]).build()\n",
  "TIMER.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nimport time\n\n\n@flojoy\ndef TIMER(v, params):\n    print(\"executing timer\")\n\n    seconds = int(params[\"sleep_time\"])\n    time.sleep(seconds)\n\n    return JobResultBuilder().from_inputs(v).build()\n",
  "CONDITIONAL.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nfrom utils.utils import compare_values\n\n\n@flojoy\ndef CONDITIONAL(v, params):\n    operator = params[\"operator_type\"]\n\n    x = v[1].y\n    y = v[0].y\n    bool_ = compare_values(x[0], y[0], operator)\n\n    data = None\n    if operator in [\"<=\", \"<\"]:\n        if not bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n    else:\n        if bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n\n    next_direction = str(bool_).lower()\n\n    return (\n        JobResultBuilder().from_data(data).flow_to_directions([next_direction]).build()\n    )\n",
  "LOOP.py": "import json\n\nfrom node_sdk.small_memory import SmallMemory\n\nfrom flojoy import JobResultBuilder, flojoy\n\nmemory_key = \"loop-info\"\n\n\nclass LoopData:\n    def __init__(\n        self, node_id, num_loops=-1, current_iteration=0, is_finished=False\n    ) -> None:\n        self.node_id = node_id\n        self.num_loops = int(num_loops)\n        self.current_iteration = int(current_iteration)\n        self.is_finished = bool(is_finished)\n\n    def restart(self):\n        self.current_iteration = 0\n        self.is_finished = False\n\n    def step(self):\n        self.current_iteration += 1\n        if self.current_iteration > self.num_loops:\n            self.is_finished = True\n\n    def get_data(self):\n        return {\n            \"node_id\": self.node_id,\n            \"num_loops\": self.num_loops,\n            \"current_iteration\": self.current_iteration,\n            \"is_finished\": self.is_finished,\n        }\n\n    @staticmethod\n    def from_data(node_id, data):\n        loop_data = LoopData(\n            node_id,\n            num_loops=data.get(\"num_loops\", -1),\n            current_iteration=data.get(\"current_iteration\", 0),\n            is_finished=data.get(\"is_finished\", False),\n        )\n        return loop_data\n\n    def print(self, prefix=\"\"):\n        print(f\"{prefix}loop Data:\", json.dumps(self.get_data(), indent=2))\n\n\n@flojoy\ndef LOOP(v, params):\n    num_loops = params.get(\"num_loops\", 0)\n    node_id = params.get(\"node_id\", 0)\n\n    print(\"\\n\\nstart loop:\", node_id)\n\n    # infinite loop\n    if num_loops == -1:\n        print(\"infinite loop\")\n        return build_result(inputs=v, is_loop_finished=False)\n\n    loop_data: LoopData = load_loop_data(node_id, num_loops)\n    loop_data.print(\"at start \")\n\n    # loop was previously finished, but now re-executing, so restart\n    if loop_data.is_finished:\n        loop_data.restart()\n    else:\n        loop_data.step()\n\n    if not loop_data.is_finished:\n        store_loop_data(node_id, loop_data)\n    else:\n        print(\"finished loop\")\n        delete_loop_data(node_id)\n\n    print(\"end loop\\n\\n\")\n\n    return build_result(v, loop_data.is_finished)\n\n\ndef load_loop_data(node_id, default_num_loops) -> LoopData:\n    data = SmallMemory().read_memory(node_id, memory_key)\n    loop_data = LoopData.from_data(\n        node_id=node_id, data={\"num_loops\": default_num_loops, **data}\n    )\n    return loop_data\n\n\ndef store_loop_data(node_id, loop_data: LoopData):\n    SmallMemory().write_to_memory(node_id, memory_key, loop_data.get_data())\n    loop_data.print(\"store \")\n\n\ndef delete_loop_data(node_id):\n    SmallMemory().delete_object(node_id, memory_key)\n    print(\"delete loop data\")\n\n\ndef build_result(inputs, is_loop_finished):\n    return (\n        JobResultBuilder()\n        .from_inputs(inputs)\n        .flow_by_flag(\n            flag=is_loop_finished,\n            directionsWhenFalse=[\"body\"],\n            directionsWhenTrue=[\"end\"],\n        )\n        .build()\n    )\n",
  "GOTO.py": "from flojoy import JobResultBuilder, flojoy\n\n\n@flojoy\ndef GOTO(v, params):\n    goto_node_id = params.get(\"goto_node_id\", None)\n    next_nodes = [goto_node_id] if goto_node_id is not None else []\n\n    return JobResultBuilder().from_inputs(v).flow_to_nodes(next_nodes).build()\n"
}
