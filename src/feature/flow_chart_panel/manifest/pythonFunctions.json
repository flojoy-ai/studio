{
  "FEEDBACK.py": "from flojoy import flojoy, DataContainer\nimport os\nfrom redis import Redis\nfrom rq.job import Job, NoSuchJobError\nimport traceback\nREDIS_HOST = os.environ.get('REDIS_HOST', 'localhost')\nREDIS_PORT = os.environ.get('REDIS_PORT', 6379)\n\n\n@flojoy\ndef FEEDBACK(v, params):\n    referred_node = params['referred_node']\n\n    x = v[0].y\n\n    try:\n        job = Job.fetch(referred_node, connection=Redis(\n            host=REDIS_HOST, port=REDIS_PORT))\n        y = job.result.y\n    except (Exception, NoSuchJobError):\n        y = v[0].y if len(v) > 0 else [1, 3, 2]\n        print(traceback.format_exc())\n        pass;\n\n    return DataContainer(x=x, y=y)\n",
  "TIMESERIES.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport pandas.util.testing as testing\nimport traceback\n\n@flojoy\ndef TIMESERIES(v, params):\n    \"\"\"\n    Generates a random timeseries vector\n    \"\"\"\n\n    try:\n        np.random.seed(1)\n        testing.N, testing.K = 1000, 1 # rows, columns\n        df = testing.makeTimeDataFrame(freq='MS')\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(x = df.index.to_numpy(), y = df['A'].to_numpy())",
  "SINE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom scipy import signal\n\n@flojoy\ndef SINE(v, params):\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n\n    waveform = params['waveform']\n    A = float(params['amplitude'])\n    F = float(params['frequency'])\n    Y0 =float( params['offset'])\n    PHASE = float(params['phase'])\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print('invalid waveform passed as param, using default:', waveform)\n\n    if waveform == 'sine':\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x + np.radians(PHASE))\n    elif waveform == 'square':\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10 + np.radians(PHASE))\n    elif waveform == 'triangle':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10 + np.radians(PHASE), 0.5)\n    elif waveform == 'sawtooth':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x + np.radians(PHASE))\n\n    return DataContainer(x = x, y = y)\n",
  "LINSPACE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef LINSPACE(v, params):\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n    y = np.linspace(float(params['start']), float(params['end']), int(params['step']))\n    result = DataContainer(x = x, y = y)\n    return result",
  "CONSTANT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef CONSTANT(v, params):\n    ''' Generates a single x-y vector of numeric (floating point) constants'''\n    \n\n    if v.__len__() > 0:\n        x = v[0].y\n        y = np.full(len(x), float(params['constant']))\n        return DataContainer(x = x, y = y)\n\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params['constant']))\n\n    return DataContainer(x = x, y = y)\n",
  "RAND.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport traceback\n\n@flojoy\ndef RAND(v, params):\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = np.random.normal(size=len(x))\n    else:\n        y = np.random.normal(size=1000)\n\n    return DataContainer(x=x, y=y)\n\n\n@flojoy\ndef RAND_MOCK(v, params):\n    print('running mock version of rand')\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = x\n    else:\n        y = np.full(1000, 1000) # for reproducibility returning an array with constant values\n    return DataContainer(x=x, y=y)",
  "OBJECT_DETECTION.py": "import traceback\nfrom flojoy import flojoy, DataContainer\n\nfrom utils.object_detection.object_detection import detect_object\n\n\n@flojoy\ndef OBJECT_DETECTION(v, params):\n    try:\n        print('Detecting objects...')\n        data = v[0].y[0]\n        y = [detect_object(data)]\n        file_type = v[0].file_type\n        return DataContainer(type='file', y=y, file_type=file_type)\n    except Exception:\n        print(traceback.format_exc())\n        raise\n",
  "ADD.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef ADD(v, params):\n    ''' Add 2 input vectors and return the result '''\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n\n    y = np.add(a, b)\n\n    return DataContainer(x = {'a': a, 'b': b}, y = y)",
  "MULTIPLY.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MULTIPLY(v, params):\n    ''' Takes 2 input vectors, multiplies them, and returns the result '''\n    a = v[0].y\n    b = v[1].y\n    y = np.multiply(a, b)\n    return DataContainer(x={'a':a, 'b':b}, y=y)\n",
  "SUBTRACT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef SUBTRACT(v, params):\n    ''' Subtract 2 input vectors and return the result '''\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n\n    y = np.subtract(a, b)\n\n    return DataContainer(x = [a, b], y = y)",
  "HISTOGRAM.py": "from flojoy import flojoy, JobResultBuilder\n\n@flojoy\ndef HISTOGRAM(v, params):\n    return JobResultBuilder().from_inputs(v).build()",
  "IMAGE.py": "from flojoy import flojoy\nfrom ..VISORS.template import init_template\n\n@flojoy\ndef IMAGE(v, params):\n\n    fig = dict(\n        data = [dict(\n            y = list(v[0].y[0]),\n            type='image'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig",
  "template.py": "import plotly.graph_objects as go\n\ndef init_template():\n\n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n\n",
  "SCATTER3D.py": "from flojoy import flojoy, JobResultBuilder\nfrom .template import init_template\n\n@flojoy\ndef SCATTER3D(v, params):\n    return JobResultBuilder().from_inputs(v).build()",
  "SURFACE3D.py": "from flojoy import flojoy, JobResultBuilder\n\n@flojoy\ndef SURFACE3D(v, params):\n    return JobResultBuilder().from_inputs(v).build()",
  "LINE.py": "from flojoy import flojoy, JobResultBuilder\n\n@flojoy\ndef LINE(v, params):\n    return JobResultBuilder().from_inputs(v).build()\n",
  "SCATTER.py": "from flojoy import flojoy, JobResultBuilder\n\n@flojoy\ndef SCATTER(v, params):\n    return JobResultBuilder().from_inputs(v).build()",
  "BAR.py": "from flojoy import flojoy, JobResultBuilder\n\n@flojoy\ndef BAR(v, params):\n    return JobResultBuilder().from_inputs(v).build()",
  "CONDITIONAL.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nfrom utils.utils import compare_values\n\n\n@flojoy\ndef CONDITIONAL(v, params):\n    operator = params['operator_type']\n\n    x = v[1].y\n    y = v[0].y\n    bool_ = compare_values(x[0], y[0], operator)\n    \n    data = None\n    if operator in [\"<=\", \"<\"]:\n        if not bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n    else:\n        if bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n\n    next_direction = str(bool_).lower()\n\n    return JobResultBuilder().from_data(data).flow_to_directions([next_direction]).build()",
  "LOOP.py": "import json\n\nfrom node_sdk.small_memory import SmallMemory\n\nfrom flojoy import JobResultBuilder, flojoy\n\nmemory_key = 'loop-info'\n\n\nclass LoopData:\n    def __init__(self, node_id, num_loops=-1, current_iteration=0, is_finished=False) -> None:\n        self.node_id = node_id\n        self.num_loops = int(num_loops)\n        self.current_iteration = int(current_iteration)\n        self.is_finished = bool(is_finished)\n\n    def restart(self):\n        self.current_iteration = 0\n        self.is_finished = False\n\n    def step(self):\n        self.current_iteration += 1\n        if self.current_iteration > self.num_loops:\n            self.is_finished = True\n\n    def get_data(self):\n        return {\n            'node_id': self.node_id,\n            'num_loops': self.num_loops,\n            'current_iteration': self.current_iteration,\n            'is_finished': self.is_finished\n        }\n\n    @staticmethod\n    def from_data(node_id, data):\n        loop_data = LoopData(\n            node_id,\n            num_loops=data.get('num_loops', -1),\n            current_iteration=data.get('current_iteration', 0),\n            is_finished=data.get('is_finished', False)\n        )\n        return loop_data\n\n    def print(self, prefix=''):\n        print(F'{prefix}loop Data:', json.dumps(self.get_data(), indent=2))\n\n\n@flojoy\ndef LOOP(v, params):\n    num_loops = params.get('num_loops', 0)\n    node_id = params.get('node_id', 0)\n    \n    print('\\n\\nstart loop:', node_id)\n\n\n    # infinite loop\n    if num_loops == -1:\n        print('infinite loop')\n        return build_result(inputs=v, is_loop_finished=False)\n\n    loop_data: LoopData = load_loop_data(node_id, num_loops)\n    loop_data.print('at start ')\n\n    # loop was previously finished, but now re-executing, so restart\n    if loop_data.is_finished:\n        loop_data.restart()\n    else:\n        loop_data.step()\n\n    if not loop_data.is_finished:\n        store_loop_data(node_id, loop_data)\n    else:\n        print('finished loop')\n        delete_loop_data(node_id)\n\n    print('end loop\\n\\n')\n\n    return build_result(v, loop_data.is_finished)\n    \n\n\ndef load_loop_data(node_id, default_num_loops) -> LoopData:\n    data = SmallMemory().read_memory(node_id, memory_key)\n    loop_data = LoopData.from_data(\n        node_id=node_id,\n        data={'num_loops': default_num_loops, **data}\n    )\n    return loop_data\n\n\ndef store_loop_data(node_id, loop_data: LoopData):\n    SmallMemory().write_to_memory(node_id, memory_key, loop_data.get_data())\n    loop_data.print('store ')\n\ndef delete_loop_data(node_id):\n    SmallMemory().delete_object(node_id, memory_key)\n    print('delete loop data')\n\n\ndef build_result(inputs, is_loop_finished):\n    return JobResultBuilder() \\\n        .from_inputs(inputs) \\\n        .flow_by_flag(\n            flag=is_loop_finished,\n            directionsWhenFalse=['body'],\n            directionsWhenTrue=['end']) \\\n        .build()\n",
  "GOTO.py": "from flojoy import JobResultBuilder, flojoy\n\n\n@flojoy\ndef GOTO(v, params):\n    goto_node_id = params.get('goto_node_id', None)\n    next_nodes = [goto_node_id] if goto_node_id is not None else []\n\n    return JobResultBuilder()\\\n        .from_inputs(v)\\\n        .flow_to_nodes(next_nodes)\\\n        .build()\n",
  "TIMER.py": "from flojoy import flojoy,DataContainer, JobResultBuilder\nimport time\n\n@flojoy\ndef TIMER(v,params):\n    print(\"executing timer\")\n    \n    seconds = int(params['sleep_time'])\n    time.sleep(seconds)\n    \n    return JobResultBuilder() \\\n        .from_inputs(v) \\\n        .build()",
  "FIR.py": "from scipy import signal\nfrom flojoy import flojoy, DataContainer\nimport numpy as np\n\n@flojoy\ndef FIR(v, params):\n    ''' Apply a low-pass FIR filter to an input vector. This\n    filter takes a few inputs: the sample_rate (will be passed as a parameter\n    if the target node is not connected), the desired width of the \n    transition to the stop band and the corresponding attentuation, and\n    lastly the cutoff frequency. '''\n\n    sample_rate = float(params['sample_rate']) #Hz\n    transition_width = float(params['transition_width']) #Hz\n    stop_band_attenuation = float(params['stop_band_attenuation']) # dB\n    cutoff_freq = float(params['cutoff_freq']) # Hz\n    print(f'FIR params: {[sample_rate,transition_width,stop_band_attenuation,cutoff_freq]}')\n\n    try:\n        times = v[1].y#v[0].x['i']\n        x = v[0].y #this is the value of the signal\n    except IndexError: #nothing input\n        # lets create some default behaviour for testing\n        nsamples = 400\n        times = np.arange(nsamples) / sample_rate\n        test_x = np.cos(2*np.pi*0.5*times) + 0.2*np.sin(2*np.pi*2.5*times+0.1) + \\\n                0.2*np.sin(2*np.pi*15.3*times) + 0.1*np.sin(2*np.pi*16.7*times + 0.1) + \\\n                    0.1*np.sin(2*np.pi*23.45*times+.8)\n        x = test_x\n\n    # first we need to define the nyquist rate ...\n    nyq_rate = sample_rate / 2.0\n    # ... then the transition width relative to this\n    transition_width /= nyq_rate\n\n    # Now compute order and Kaiser param for the fitler\n    N, beta = signal.kaiserord(stop_band_attenuation,transition_width)\n\n    # Now we create the filter with the Kaiser window ...\n    taps = signal.firwin(N, cutoff_freq/nyq_rate, window = ('kaiser', beta))\n\n    # ... and then apply it to the signal\n    filtered_x = signal.lfilter(taps, 1.0, x)\n\n    # Now, there are two considerations to be had. Firstly, \n    # there is a phase delay in the signal since we have applied finite\n    # taps ...\n    phase_delay = 0.5 * (N-1) / sample_rate\n    # ... and furthermore, the first N-1 samples are 'corrupted' in \n    # the sense that the filter 'sacrifies' them by the imposition \n    # of the initial conditions.\n    times = times[N-1:] - phase_delay\n    filtered_x = filtered_x[N-1:]\n    \n    return DataContainer(x = times, y = filtered_x)\n",
  "BUTTER.py": "from scipy import signal\nimport numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef BUTTER(v, params):\n    ''' Apply a butterworth filter to an input vector '''\n\n    print('Butterworth inputs:', v)\n\n    sig = v[0].y\n\n    sos = signal.butter(10, 15, 'hp', fs=1000, output='sos')\n    filtered = signal.sosfilt(sos, sig)\n\n    return DataContainer(x = sig, y = filtered)\n",
  "SAVGOL.py": "import scipy\nfrom flojoy import flojoy, DataContainer\nimport warnings\n\n\n@flojoy\ndef SAVGOL(v, params):\n    ''' Apply a Savitzky-Golay filter to an input vector.\n    The default behaviour is implementing a 3-point moving average of the data. '''\n    print('Savgol inputs:', v)\n    signal = v[0].y\n    window_length = int(params['wlen'])\n    poly_order = int(params['porder'])\n    if poly_order >= window_length:\n        warnings.warn(\"Polynomial order is greater than the window size. Using p=w-1...\")\n        poly_order = window_length - 1\n    filtered = scipy.signal.savgol_filter(signal, window_length,poly_order)\n    return DataContainer(x = signal, y = filtered)\n",
  "CAMERA.py": "import cv2\nimport os\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef CAMERA(v, params):\n    '''\n    Take a picture from a connected camera using OpenCV.\n    If no camera is connected, this will load the example image: \"object_detection.png\".\n    '''\n    print('parameters passed to CAMERA: ', params)\n    y = {}\n    camera_test = False  # Value to test if image is the default image.\n\n    try:\n        camera = cv2.VideoCapture(params['camera_ind'])  # Camera indicator for selection of specific camera\n        return_value, image = camera.read()  # Read camera\n        filePath = \"camera.png\"\n        cv2.imwrite(filePath, image)\n        camera_test = True\n    except cv2.error as camera_error:  # Catch error for when a camera isn't detected.\n        print('OpenCV cannot read the specified camera.')\n        filePath = \"../public/assets/object_detection.png\"  # Load example image instead. Should it throw an error?\n\n    # Load the file then delete if it's the file from the camera.\n    print (\"File to be loaded: \" + filePath)\n    with open(filePath, \"rb\") as fileToBeLoaded:\n        f = fileToBeLoaded.read()\n        y = [bytearray(f)]\n    fileToBeLoaded.close()\n\n    if camera_test:\n        os.remove(filePath)\n    camera.release()\n    del(camera)\n\n    return DataContainer(type = 'file', y = y, file_type = ['image'])\n",
  "LOCAL_FILE.py": "import traceback\nfrom flojoy import flojoy,DataContainer\n\n@flojoy\ndef LOCAL_FILE(v, params):\n    print('parameters passed to LOCAL_FILE: ', params)\n    try:\n        filePath = ''\n        y = {}\n        if v is not None and len(v) != 0:\n            filePath = v[0].y\n        ctrlInput = params['path']\n        fileType = params['file_type']\n        opType = params['op_type']\n        if ctrlInput is not None and len(ctrlInput.strip()) > 0:\n            filePath = ctrlInput\n        elif len(filePath.strip()) == 0:\n            if fileType == 'image' and opType == 'OD':\n                filePath = \"../public/assets/object_detection.png\"\n        print (\"File to be loaded: \" + filePath)\n        with open(filePath, \"rb\") as fileToBeLoaded:\n            f = fileToBeLoaded.read()\n            y = [bytearray(f)]\n        fileToBeLoaded.close()\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(type = 'file', y = y, file_type = [fileType])\n",
  "INVERT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef INVERT(v, params):\n    ''' Takes 2 inputs, one matrix and one rcond if not square matrix.\n    Inverts them (or pseudo invert) and returns the result. \n    If the entered value is a scalar it returns the multiplciative\n    inverse 1/x '''\n    print(f'INVERT params: {params}')\n    a = np.eye(3)\n    b = float(params['rcond'])\n\n    if v.__len__ >0:\n        if (v[0].type == 'ordered_pair'): # v[0] is a DataContainer object with type attribute\n            print('Performing simple inversion')\n            a = v[0].y #scalar valued\n            return DataContainer(x=a, y=1/a)\n        elif (v[0].type == 'matrix'):\n            a = v[0].m\n            if (not a.shape[0] == a.shape[1]):\n                print('Not square matrix! Using pseudoinversion...')\n                assert type(b)==float, \"Need scalar value to compare SVDs for pseudoinversion\"\n                retval = np.linalg.pinv(a, rcond=b, hermitian=False)\n            else:\n                try:\n                    retval = np.linalg.inv(a)\n                except np.linalg.LinAlgError:\n                    raise ValueError('Inversion failed! Singular matrix returned...')\n            return DataContainer(type='matrix',m=retval)\n        else:\n            raise ValueError('Incorrect input DataContainer type.')\n    else:\n        return DataContainer(type='matrix',m=np.eye(3))\n",
  "MATMUL.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef MATMUL(v, params):\n    ''' Takes 2 input matrices, multiplies them, and returns the result '''\n    a = np.eye(3)\n    b = np.eye(3)\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n    return DataContainer(type='matrix', m=np.matmul(a, b))",
  "END.py": "from flojoy import flojoy, JobResultBuilder\n\n\n@flojoy\ndef END(v, params):\n    return JobResultBuilder()\\\n        .from_inputs(v)\\\n        .flow_to_nodes([])\\\n        .build()\n"
}