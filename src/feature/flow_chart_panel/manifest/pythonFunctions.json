{
  "LOADER.py": "import json\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport requests\nimport yaml\nfrom flojoy import DataContainer, flojoy\nfrom flojoy.utils import PlotlyJSONEncoder\n\nFRONTIER_HOST= os.environ.get('FRONTIER_HOST')\nFORNTIER_PORT = os.environ.get('FRONTIER_PORT')\nAPI_URI= f\"https://{FRONTIER_HOST}:{FORNTIER_PORT}/measurements\"\n\n\n@flojoy\ndef LOADER(dc_inputs:list[DataContainer], params:dict):\n    api_key = get_api_key()\n    measurement_uuid = params['measurement_uuid']\n    \n    if api_key != '' and measurement_uuid != '':\n        try:\n            requests.post(f'{API_URI}/{measurement_uuid}', \n                      json={'api_key':api_key, \n                            'measurements': json.dumps({'data':dc_inputs[0]}, cls=PlotlyJSONEncoder),\n                            'time': datetime.now().__str__()})\n        except Exception as e:\n            raise e\n        return dc_inputs[0]\n    else:\n        not_found_key = 'FRONTIER_API_KEY' if api_key == '' else 'Measurement UUID'\n        raise KeyError(f'{not_found_key} not found!')\n\n\ndef get_api_key():\n    home = str(Path.home())\n    api_key = ''\n    path = os.path.join(home, '.flojoy/credentials')\n    if not os.path.exists(path):\n        return api_key\n    \n    stream = open(path, 'r', encoding='utf-8')\n    yaml_dict = yaml.load(stream, Loader=yaml.FullLoader)\n    if yaml_dict is None:\n        return api_key\n    if isinstance(yaml_dict, str) == True:\n        split_by_line = yaml_dict.split('\\n')\n        for line in split_by_line:\n            if 'FRONTIER_API_KEY' in line:\n                api_key = line.split(':')[1]\n    else:\n        api_key = yaml_dict.get('FRONTIER_API_KEY', '')\n    return api_key",
  "LOCAL_FILE.py": "import traceback\nfrom flojoy import flojoy,DataContainer, JobResultBuilder\nimport numpy as np\nfrom PIL import Image\nfrom os import path\n\n@flojoy\ndef LOCAL_FILE(v, params):\n    print('parameters passed to LOCAL_FILE: ', params)\n    file_type = params.get('file_type', 'image')\n    match file_type:\n        case 'image':       \n            red_channel = []\n            green_channel = []\n            blue_channel = []\n            alpha_channel = []\n            try:\n                filePath = ''\n                ctrlInput = params['path']\n                opType = params['op_type']\n                if ctrlInput is not None and len(ctrlInput.strip()) > 0:\n                    filePath = ctrlInput\n                elif len(filePath.strip()) == 0:\n                    if opType == 'OD':\n                        filePath = path.join(path.dirname(path.abspath(__file__)), \"assets\", \"object_detection.png\")\n                print (\"File to be loaded: \" + filePath)\n                f = Image.open(filePath)\n                img_array = np.array(f.convert('RGBA'))\n                if img_array.shape[2] == 4:\n                    red_channel = img_array[:,:,0]\n                    green_channel = img_array[:,:,1]\n                    blue_channel = img_array[:,:,2]\n                    alpha_channel = img_array[:,:,3]\n                else:\n                    red_channel = img_array[:,:,0]\n                    green_channel = img_array[:,:,1]\n                    blue_channel = img_array[:,:,2]\n                    alpha_channel = None\n            except Exception:\n                print(traceback.format_exc())\n            return DataContainer(type = 'image',r=red_channel, g=green_channel, b=blue_channel, a=alpha_channel)\n        case _:\n            return JobResultBuilder().from_inputs(v).build()\n",
  "OBJECT_DETECTION.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\n\nfrom utils.object_detection.object_detection import detect_object\n\n\n@flojoy\ndef OBJECT_DETECTION(v, params):\n    try:\n        red_channel = []\n        green_channel = []\n        blue_channel = []\n        alpha_channel = []\n        print('Detecting objects...')\n        r = v[0].r\n        g = v[0].g\n        b = v[0].b\n        a = v[0].a\n        print(\" a here: \", a)\n        if a is not None:\n            nparr = np.stack((r, g, b, a), axis=2)\n        else:\n            nparr = np.stack((r, g, b), axis=2)\n        img_array = detect_object(nparr)\n        if img_array.shape[2] == 4:\n            red_channel = img_array[:,:,0]\n            green_channel = img_array[:,:,1]\n            blue_channel = img_array[:,:,2]\n            alpha_channel = img_array[:,:,3]\n        else:\n            red_channel = img_array[:,:,0]\n            green_channel = img_array[:,:,1]\n            blue_channel = img_array[:,:,2]\n            alpha_channel = None\n        return DataContainer(type = 'image',r=red_channel, g=green_channel, b=blue_channel, a=alpha_channel)\n    \n    except Exception:\n        print(traceback.format_exc())\n        raise\n",
  "FEEDBACK.py": "from flojoy import flojoy, DataContainer, get_job_result\nfrom rq.job import NoSuchJobError\nimport traceback\n\n\n@flojoy\ndef FEEDBACK(v, params):\n    referred_node = params['referred_node']\n    \n    try:\n        result = get_job_result(referred_node)\n        return result\n    except (Exception, NoSuchJobError) as e:\n        x = v[0].x\n        y = v[0].y\n        print(\"Job not found: \", e, traceback.format_exc())\n        return DataContainer(x=x, y=y)\n\n",
  "CONSTANT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef CONSTANT(v, params):\n    ''' Generates a single x-y vector of numeric (floating point) constants'''\n    \n\n    if v.__len__() > 0:\n        x = v[0].y\n        y = np.full(len(x), float(params['constant']))\n        return DataContainer(x = x, y = y)\n\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params['constant']))\n\n    return DataContainer(x = x, y = y)\n",
  "SINE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom scipy import signal\n\n@flojoy\ndef SINE(v, params):\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n\n    waveform = params['waveform']\n    A = float(params['amplitude'])\n    F = float(params['frequency'])\n    Y0 =float( params['offset'])\n    PHASE = float(params['phase'])\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print('invalid waveform passed as param, using default:', waveform)\n\n    if waveform == 'sine':\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x + np.radians(PHASE))\n    elif waveform == 'square':\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10 + np.radians(PHASE))\n    elif waveform == 'triangle':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10 + np.radians(PHASE), 0.5)\n    elif waveform == 'sawtooth':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x + np.radians(PHASE))\n\n    return DataContainer(x = x, y = y)\n",
  "SECOND_ORDER_SYSTEM.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = 'SECOND_ORDER_SYSTEM'\n\n@flojoy\ndef SECOND_ORDER_SYSTEM(v, params):\n    # Let's first define things that won't change over\n    # each iteration: time constants, etc ...\n    d1 = float(params['d1']) #first time constant in us, 250\n    d2 = float(params['d2']) #second time constant in us, 100\n    node_id = params.get('node_id', 0)\n\n    # ... and now some helper functions\n    x1 = np.exp(-1.0 / d1) if d1 > 0 else 0.0\n    x2 = np.exp(-1.0 / d2) if d2 > 0 else 0.0\n    ac = (1.0 - x1) * (1.0 - x2)\n    bpd = x1 + x2\n    bd = x1 * x2\n\n    # Now we require memory. The only thing we need in memory is the last two \n    # values the system had in this basic example.\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Error loading object from REDIS.\")\n    \n    # We're going to store and read the data in reverse order to\n    # how it is accessed here. We will write the functionality\n    # below to assume the most recent time step is the first\n    # index. However, for visualization and external access,\n    # it makes the most sense to have the first time step\n    # as the first index!\n    y_primes = np.zeros((2,1)) if initialize else data[::-1]\n \n    # Using input from controller as v[0].y ...\n    response = ac * v[0].y[-1] + bpd * y_primes[0] - bd * y_primes[1]\n    y_primes[1] = y_primes[0]\n\n    #prepend the most recent result to the front of the histrory\n    y_primes = np.insert(y_primes, 0, response)\n    # We now write to memory, reversing the order ...\n    SmallMemory().write_to_memory(node_id, memory_key, y_primes[::-1])\n    # ... and return the result!\n    return DataContainer(x=v[0].y, y=np.ones_like(v[0].y)*float(y_primes[0])) #returns input output pair",
  "TIMESERIES.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport pandas.util.testing as testing\nimport traceback\n\n@flojoy\ndef TIMESERIES(v, params):\n    \"\"\"\n    Generates a random timeseries vector\n    \"\"\"\n\n    try:\n        np.random.seed(1)\n        testing.N, testing.K = 1000, 1 # rows, columns\n        df = testing.makeTimeDataFrame(freq='MS')\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(x = df.index.to_numpy(), y = df['A'].to_numpy())",
  "RAND.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport traceback\n\n@flojoy\ndef RAND(v, params):\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = np.random.normal(size=len(x))\n    else:\n        y = np.random.normal(size=1000)\n\n    return DataContainer(x=x, y=y)\n\n\n@flojoy\ndef RAND_MOCK(v, params):\n    print('running mock version of rand')\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = x\n    else:\n        y = np.full(1000, 1000) # for reproducibility returning an array with constant values\n    return DataContainer(x=x, y=y)",
  "LINSPACE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef LINSPACE(v, params):\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n    y = np.linspace(float(params['start']), float(params['end']), int(params['step']))\n    result = DataContainer(x = x, y = y)\n    return result",
  "MULTIPLY.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MULTIPLY(v, params):\n    ''' Takes 2 input vectors, multiplies them, and returns the result '''\n    a = v[0].y\n    b = v[1].y\n    y = np.multiply(a, b)\n    return DataContainer(x={'a':a, 'b':b}, y=y)\n",
  "ABS.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef ABS(v, params):\n    ''' Returns abolute value '''\n    return DataContainer(x=v[0].y, y=np.abs(v[0].y))",
  "ADD.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef ADD(v, params):\n    ''' Add 2 input vectors and return the result '''\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n\n    y = np.add(a, b)\n\n    return DataContainer(x = {'a': a, 'b': b}, y = y)",
  "SUBTRACT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef SUBTRACT(v, params):\n    ''' Subtract 2 input vectors and return the result '''\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n\n    y = np.subtract(a, b)\n\n    return DataContainer(x = {'a':a,'b':b}, y = y)",
  "INVERT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef INVERT(v, params):\n    ''' Takes 2 inputs, one matrix and one rcond if not square matrix.\n    Inverts them (or pseudo invert) and returns the result. \n    If the entered value is a scalar it returns the multiplciative\n    inverse 1/x '''\n    print(f'INVERT params: {params}')\n    a = np.eye(3)\n    b = float(params['rcond'])\n\n    if v.__len__ >0:\n        if (v[0].type == 'ordered_pair'): # v[0] is a DataContainer object with type attribute\n            print('Performing simple inversion')\n            a = v[0].y #scalar valued\n            return DataContainer(x=a, y=1/a)\n        elif (v[0].type == 'matrix'):\n            a = v[0].m\n            if (not a.shape[0] == a.shape[1]):\n                print('Not square matrix! Using pseudoinversion...')\n                assert type(b)==float, \"Need scalar value to compare SVDs for pseudoinversion\"\n                retval = np.linalg.pinv(a, rcond=b, hermitian=False)\n            else:\n                try:\n                    retval = np.linalg.inv(a)\n                except np.linalg.LinAlgError:\n                    raise ValueError('Inversion failed! Singular matrix returned...')\n            return DataContainer(type='matrix',m=retval)\n        else:\n            raise ValueError('Incorrect input DataContainer type.')\n    else:\n        return DataContainer(type='matrix',m=np.eye(3))\n",
  "MATMUL.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef MATMUL(v, params):\n    ''' Takes 2 input matrices, multiplies them, and returns the result '''\n    a = np.eye(3)\n    b = np.eye(3)\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n    return DataContainer(type='matrix', m=np.matmul(a, b))",
  "PID.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = 'pid-info'\n\n@flojoy\ndef PID(v, params):\n    # First let's get the parameters that won't change\n    Kp = float(params['Kp'])\n    Ki = float(params['Ki'])\n    Kd = float(params['Kd'])\n    node_id = params.get('node_id', 0)\n    # Now we need some memory! We need to keep track of the running\n    # integral value of the inputs (regulation errors), as well as\n    # the previous 3 values of the regulation error\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Issue reading memory from REDIS.\")\n    integral = 0 if initialize else data[0]\n    regulation_error_primes = np.zeros((3,1)) if initialize else data[1:]\n    print(f'Recovered data: {data}')\n\n    regulation_error = v[0].y[-1] #constant node makes long list of items; just need the value so take last element\n    integral += (\n        0.5 * Ki * (regulation_error + regulation_error_primes[0])\n    )\n    output_signal = (\n        Kp * regulation_error\n        + integral\n        + 0.1667\n        * Kd\n        * (\n            regulation_error\n            - regulation_error_primes[2]\n            + 3.0\n            * (regulation_error_primes[0] - regulation_error_primes[1])\n        )\n    )\n    regulation_error_primes[2] = regulation_error_primes[1]\n    regulation_error_primes[1] = regulation_error_primes[0]\n    regulation_error_primes[0] = regulation_error\n\n    # Now write to memory ...\n    SmallMemory().write_to_memory(\n        node_id,\n        memory_key, \n        np.append(integral, regulation_error_primes)\n    )\n    print(regulation_error, output_signal)\n    # ... and return the result\n    return DataContainer(x=v[0].y, y=np.ones_like(v[0].y)*output_signal)",
  "BUTTER.py": "from scipy import signal\nimport numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef BUTTER(v, params):\n    ''' Apply a butterworth filter to an input vector '''\n\n    print('Butterworth inputs:', v)\n\n    sig = v[0].y\n\n    sos = signal.butter(10, 15, 'hp', fs=1000, output='sos')\n    filtered = signal.sosfilt(sos, sig)\n\n    return DataContainer(x = sig, y = filtered)\n",
  "SAVGOL.py": "import scipy\nfrom flojoy import flojoy, DataContainer\nimport warnings\n\n\n@flojoy\ndef SAVGOL(v, params):\n    ''' Apply a Savitzky-Golay filter to an input vector.\n    The default behaviour is implementing a 3-point moving average of the data. '''\n    print('Savgol inputs:', v)\n    signal = v[0].y\n    window_length = int(params['wlen'])\n    poly_order = int(params['porder'])\n    if poly_order >= window_length:\n        warnings.warn(\"Polynomial order is greater than the window size. Using p=w-1...\")\n        poly_order = window_length - 1\n    filtered = scipy.signal.savgol_filter(signal, window_length,poly_order)\n    return DataContainer(x = signal, y = filtered)\n",
  "FIR.py": "from scipy import signal\nfrom flojoy import flojoy, DataContainer\nimport numpy as np\n\n@flojoy\ndef FIR(v, params):\n    ''' Apply a low-pass FIR filter to an input vector. This\n    filter takes a few inputs: the sample_rate (will be passed as a parameter\n    if the target node is not connected), the desired width of the \n    transition to the stop band and the corresponding attentuation, and\n    lastly the cutoff frequency. '''\n\n    sample_rate = float(params['sample_rate']) #Hz\n    transition_width = float(params['transition_width']) #Hz\n    stop_band_attenuation = float(params['stop_band_attenuation']) # dB\n    cutoff_freq = float(params['cutoff_freq']) # Hz\n    print(f'FIR params: {[sample_rate,transition_width,stop_band_attenuation,cutoff_freq]}')\n\n    try:\n        times = v[1].y#v[0].x['i']\n        x = v[0].y #this is the value of the signal\n    except IndexError: #nothing input\n        # lets create some default behaviour for testing\n        nsamples = 400\n        times = np.arange(nsamples) / sample_rate\n        test_x = np.cos(2*np.pi*0.5*times) + 0.2*np.sin(2*np.pi*2.5*times+0.1) + \\\n                0.2*np.sin(2*np.pi*15.3*times) + 0.1*np.sin(2*np.pi*16.7*times + 0.1) + \\\n                    0.1*np.sin(2*np.pi*23.45*times+.8)\n        x = test_x\n\n    # first we need to define the nyquist rate ...\n    nyq_rate = sample_rate / 2.0\n    # ... then the transition width relative to this\n    transition_width /= nyq_rate\n\n    # Now compute order and Kaiser param for the fitler\n    N, beta = signal.kaiserord(stop_band_attenuation,transition_width)\n\n    # Now we create the filter with the Kaiser window ...\n    taps = signal.firwin(N, cutoff_freq/nyq_rate, window = ('kaiser', beta))\n\n    # ... and then apply it to the signal\n    filtered_x = signal.lfilter(taps, 1.0, x)\n\n    # Now, there are two considerations to be had. Firstly, \n    # there is a phase delay in the signal since we have applied finite\n    # taps ...\n    phase_delay = 0.5 * (N-1) / sample_rate\n    # ... and furthermore, the first N-1 samples are 'corrupted' in \n    # the sense that the filter 'sacrifies' them by the imposition \n    # of the initial conditions.\n    times = times[N-1:] - phase_delay\n    filtered_x = filtered_x[N-1:]\n    \n    return DataContainer(x = times, y = filtered_x)\n",
  "CAMERA.py": "import cv2\nimport os\nfrom flojoy import flojoy, DataContainer\n\n@flojoy\ndef CAMERA(v, params):\n    '''\n    Take a picture from a connected camera using OpenCV.\n    If no camera is connected, this will load the example image: \"object_detection.png\".\n    Perhaps after testing is finished, an error should be thrown if no camera was detected.\n    '''\n    print('parameters passed to CAMERA: ', params)\n    y = {}\n    camera_test = False  # Value to test if image is the default image.\n\n    try:\n        camera_index = int(params.get('camera_ind', -1))\n        camera = cv2.VideoCapture(camera_index)  # Camera indicator for selection of specific camera\n        test = camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n        # print('\\n', test, '\\n')  # Print to check if setting the resolution worked.\n        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)\n\n        return_value, image = camera.read()  # Read camera. Return value can be useful for testing.\n        if image is None:\n            raise cv2.error\n\n        # print(image.shape)\n        camera_test = True  # Camera has been detected.\n        camera.release()  # Release the camera for further use.\n        del(camera)\n\n    except cv2.error as camera_error:  # Catch error for when a camera isn't detected. Should it throw an error for production?\n        pass\n\n    if not camera_test:\n        print('OpenCV cannot read the specified camera.')\n        print('Loading backup image.')\n        filePath = \"../public/assets/object_detection.png\"  # Load example image instead for testing.\n        # Load the file and put into bytearray.\n        print (\"File to be loaded: \" + filePath)\n        with open(filePath, \"rb\") as fileToBeLoaded:\n            f = fileToBeLoaded.read()\n            # print(type(cv2.imread(filePath)))\n            y = [bytearray(f)]\n            # print(type(f))\n            # print(type(bytearray(f)))\n        fileToBeLoaded.close()\n\n    else:\n        f = cv2.imencode('.png', image)[1]  # encode image to pass to next node.\n        y = [bytearray(f)]\n\n    return DataContainer(type = 'file', y = y, file_type = ['image'])\n",
  "LABJACKU3.py": "from flojoy import flojoy, DataContainer\n\nimport u3                 #Import the library from LabJackPython in order to use our U3-LV device\n\n@flojoy\ndef LABJACKU3(dc, params):                           # params {nombre de sensor}\n    d = u3.U3()                                      # Create an instance of U3 class d.configU3()\n    d.configIO(FIOAnalog=255, EIOAnalog=0)           # Config the U3 for daq from temperature sensors\n\n    voltages = []                                    # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = int(params[\"numbers\"])\n\n    for i in range(1, N):                            #Loop on the number of sensor you are using\n        voltage = d.getAIN(i-1)\n        temperature = voltage * 100.0\n        temperature_celcius = (temperature - 32) / 1.8 # Convert Voltage into temperature in Celcius\n\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n    return DataContainer(x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius)\n\n\n@flojoy\ndef LABJACKU3_MOCK (dc, params):    # params {nombre de sensor}\n\n    print('running mock version of LabJackU3, number of sensor is set to 6 by default')\n\n    voltages = []                                    # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = 6                                           #Mock Number of sensors\n\n    for i in range(1, N):                            #Loop on the number of sensor you are using\n        voltage = 0.6   # Mock Value for the measured voltage\n        temperature = voltage * 100.0\n        temperature_celcius = (temperature - 32) / 1.8 # Convert Voltage into temperature in Celcius\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n\n    return DataContainer(x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius)\n",
  "PHIDGET22.py": "from flojoy import flojoy, DataContainer\nimport Phidget22\nfrom Phidget22.Phidget import *\nfrom Phidget22.Devices.VoltageRatioInput import *\n\n\ndef onVoltageRatioChange(self, voltageRatio):\n    print(\"VoltageRatio [\" + str(self.getChannel()) + \"]: \" + str(\n        voltageRatio))  # Declaration of the Event handler, Voltage changement\n\n\n@flojoy\ndef PHIDGET22(dc, params):\n    voltage = []\n    pressions = []\n    N = int(params[\"n_sensors\"])\n\n    for i in range(0, N):\n        voltageRatioInput = VoltageRatioInput()  # Creation of an instance of the VoltageRationInput class\n        voltageRatioInput.setChannel(i)  # Set Channel for Communication with the Phidget Interface Kit\n        voltageRatioInput.setOnVoltageRatioChangeHandler(\n            onVoltageRatioChange)  # Assign the handler that will be called when the event occurs\n        voltageRatioInput.openWaitForAttachment(5000)  # Open the Channel after event handler is set\n        volt_i = voltageRatioInput.getVoltageRatio()  # Measure Voltage from the sensor\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n\n        pression_i = (volt_i - 0.015) / 0.06                      # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n\n@flojoy\ndef PHIDGET22_MOCK(dc, params):\n\n    print('running mock version of PHIDGET SENSOR, number of sensor is set to 4 by default')\n\n    voltage = []\n    pressions = []\n    N = 4\n\n    for i in range(0, N):\n        volt_i = i*10 + 4                                         # Scalar operation to modify data\n        voltage.append(volt_i)                                    # Add Voltage to the list of measurements\n        pression_i = (volt_i - 0.015) / 0.06                      # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)",
  "STEPPERDRIVER_TIC_KNOB.py": "from flojoy import flojoy, DataContainer\nfrom ticlib import TicUSB\nfrom time import sleep\n\n\n@flojoy\ndef STEPPERDRIVER_TIC_KNOB(dc, params):\n    tic = TicUSB()  # Declaration of the stepper driver (You can add serial number to specify the driver)\n\n    tic.halt_and_set_position(0)  # Set the position to 0\n    tic.set_current_limit(30)  # Set the current limit to 0,34Amp, the driver needs this current to work correctly\n    tic.energize()  # Turn on the driver\n    tic.exit_safe_start()  # The driver is now ready to receive commands\n    tic.set_max_speed(2000000)  # Set maximum speed for the motor during first movement.\n\n    knob_position = 2 * int(params[\"knob_value\"])  # Retrieving data from the CRTL parameters define by the User\n\n    tic.set_target_position(knob_position)  # Set target position for the first movement\n\n    while tic.get_current_position() != tic.get_target_position():\n        print(\"Position du moteur\")\n        print(tic.get_current_position())\n        sleep(0.1)\n\n    tic.deenergize()\n    tic.enter_safe_start()\n\n    return DataContainer(x={\"a\": positions, \"b\": positions}, y=positions)\n\n\n@flojoy\ndef STEPPERDRIVER_TIC_KNOB_MOCK(dc, params):\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n",
  "STEPPERDRIVER_TIC.py": "from flojoy import flojoy, DataContainer\nfrom ticlib import TicUSB\nfrom time import sleep\n\n\n@flojoy\ndef STEPPERDRIVER_TIC(dc, params):\n    tic = TicUSB()  # Declaration of the stepper driver (You can add serial number to specify the driver)\n\n    tic.halt_and_set_position(0)  # Set the position to 0\n    tic.set_current_limit(30)  # Set the current limit to the max the driver needs this current to work correctly\n    tic.energize()  # Turn on the driver\n    tic.exit_safe_start()  # The driver is now ready to receive commands\n    positions = [int(params[\"position1\"]), int(params['position2']), int(params['position3']),\n                 int(params['position4'])]  # Retrieving data from the CRTL parameters define by the User\n\n    tic.set_target_position(positions[0])  # Set target position for the first movement\n    tic.set_max_speed(int(params[\"speed1\"]))  # Set maximum speed for the motor during first movement.\n\n    while tic.get_current_position() != tic.get_target_position():\n        print(\"Position du moteur\")\n        print(tic.get_current_position())\n        sleep(0.1)\n\n    tic.set_target_position(positions[1])   # Set target position for the second movement\n\n    while tic.get_current_position() != tic.get_target_position():\n        print(\"Vitesse du moteur en pulse/secondes: \")\n        print(tic.get_current_velocity())\n        sleep(0.1)\n\n    tic.set_max_speed(int(params[\"speed2\"]))  # Set maximum speed for the motor during movement.\n    tic.set_target_position(positions[2])\n    sleep(2)\n\n    tic.set_target_position(positions[3])\n    sleep(2)\n\n    tic.deenergize()\n    tic.enter_safe_start()\n\n    return DataContainer(x={\"a\": positions, \"b\": positions}, y=positions)\n\n\n@flojoy\ndef STEPPERDRIVER_TIC_MOCK(dc, params):\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n",
  "KEITHLEY2400.py": "import numpy as np\nimport serial\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef KEITHLEY2400 (dc,params):                  #params {comport, baudrate,timeout}\n\n    # Serial communication with the instrument configuration\n    ser = serial.Serial()\n\n    #Specific parameters\n\n    ser.port = params['comport'] # Secify serial port for com\n    ser.baudrate = params['baudrate']  # Specify Baudrate\n\n\n    #General parameters\n    ser.bytesize = serial.EIGHTBITS  # Specify Bites number\n    ser.parity = serial.PARITY_NONE  # Specify Parity\n    ser.stopbits = serial.STOPBITS_ONE  # Specify Stop bites\n    ser.timeout = 1\n    # Open Serial Com\n    ser.open()\n\n    # Keithley 2400 Configuration\n    ser.write(b'*RST\\n')  # reinitialisation of the instrument\n    ser.write(b':SOUR:FUNC:MODE VOLT\\n')  # Sourcing tension\n    ser.write(b':SENS:FUNC \"CURR\"\\n')  # Measuring current\n    ser.write(b':SENS:CURR:PROT 1.05\\n')  # Current protection set at 1.05A : Maximum for keithely 2400\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        ser.write(b':SOUR:VOLT %f\\n' % voltage)  # Source Tension (V)\n        ser.write(b':OUTP ON\\n')  # Instrument output open\n        ser.write(b':INIT\\n')  # Start measuring\n        ser.write(b':FETC?\\n')  # Retrieve the measured values\n\n        current_str = ser.readline().decode('ascii').strip()  # Save answers in a string\n        voltage_current_values = current_str.split(',')  # Split the string into measured values (Voltage, Current, Etc)\n        currents_neg.append(-float(voltage_current_values[1]))  # Converts measured currents into float\n\n        ser.write(b':OUTP OFF\\n')  # Close output from Instrument\n\n\n    # Close Serial Communication\n\n    ser.close()\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n\n\n@flojoy\ndef KEITHLEY2400_MOCK (dc,params):                  #params {comport, baudrate,timeout}\n\n    print('Running mock version of Keithley2400')\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        voltage_current_values =voltages*0.15                   # Apply a scalar operation on the mock Voltage\n        currents_neg.append(-float(voltage_current_values[1]))  # Converts measured currents into float\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n",
  "template.py": "import plotly.graph_objects as go\n\ndef init_template():\n\n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n\n",
  "SCATTER.py": "import plotly.graph_objects as go\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef SCATTER(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'ordered_pair':\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError('unsupported input type for SCATTER node')\n    fig = go.Figure(data=go.Scatter(x=x, y=y, mode='markers'))\n    return DataContainer(type='plotly', fig=fig, x=x, y=y)",
  "LINE.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\n\n@flojoy\ndef LINE(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'ordered_pair':\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError('unsupported input type for LINE node')\n    fig = go.Figure(data=go.Line(x=x, y=y, mode='markers'))\n    return DataContainer(type='plotly', fig=fig, x=x, y=y)\n\n",
  "SURFACE3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SURFACE3D(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'ordered_triple':\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError('unsupported input type for SURFACE3D node')\n    fig = go.Figure(data=go.Surface(x=x, y=y, z=z, mode='markers'))\n    return DataContainer(type='plotly', fig=fig, x=x, y=y, z=z)",
  "IMAGE.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\nimport numpy as np\n\n@flojoy\ndef IMAGE(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'image':\n        r = dc_input.r\n        g = dc_input.g\n        b = dc_input.b \n        a = dc_input.a\n    else:\n        raise ValueError('unsupported input type for IMAGE node')\n    if a is None:\n        img_combined = np.stack((r, g, b), axis=2)\n    else:\n        img_combined = np.stack(\n                    (r, g, b, a), axis=2)\n    fig= px.imshow(img=img_combined)\n    \n    return DataContainer(type='plotly', fig=fig, r=r, g=g, b=b, a=a)\n",
  "BAR.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\n\n@flojoy\ndef BAR(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'ordered_pair':\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError('unsupported input type for BAR node')\n    fig = px.scatter(x=x, y=y, mode='markers')\n    return DataContainer(type='plotly', fig=fig, x=x, y=y)",
  "SCATTER3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SCATTER3D(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'ordered_triple':\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError('unsupported input type for SCATTER3D node')\n    fig = go.Figure(data=go.Scatter3d(x=x, y=y, z=z, mode='markers'))\n    return DataContainer(type='plotly', fig=fig, x=x, y=y, z=z)",
  "HISTOGRAM.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\n\n@flojoy\ndef HISTOGRAM(v, params):\n    dc_input = v[0]\n    if dc_input.type == 'ordered_pair':\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n    else:\n        raise ValueError('unsupported type for HISTOGRAM  node')\n    fig = px.histogram(x=x, y=y)\n    return DataContainer(type='plotly', fig=fig, x=x, y=y)",
  "END.py": "from flojoy import flojoy, JobResultBuilder\n\n\n@flojoy\ndef END(v, params):\n    inputs = v if len(v) > 0 else []\n    return JobResultBuilder()\\\n        .from_inputs(inputs)\\\n        .flow_to_nodes([])\\\n        .build()\n",
  "TIMER.py": "from flojoy import flojoy,DataContainer, JobResultBuilder\nimport time\n\n@flojoy\ndef TIMER(v,params):\n    print(\"executing timer\")\n    \n    seconds = int(params['sleep_time'])\n    time.sleep(seconds)\n    \n    return JobResultBuilder() \\\n        .from_inputs(v) \\\n        .build()",
  "GOTO.py": "from flojoy import JobResultBuilder, flojoy\n\n\n@flojoy\ndef GOTO(v, params):\n    goto_node_id = params.get('goto_node_id', None)\n    next_nodes = [goto_node_id] if goto_node_id is not None else []\n\n    return JobResultBuilder()\\\n        .from_inputs(v)\\\n        .flow_to_nodes(next_nodes)\\\n        .build()\n",
  "LOOP.py": "import json\n\nfrom node_sdk.small_memory import SmallMemory\n\nfrom flojoy import JobResultBuilder, flojoy\n\nmemory_key = 'loop-info'\n\n\nclass LoopData:\n    def __init__(self, node_id, num_loops=-1, current_iteration=0, is_finished=False) -> None:\n        self.node_id = node_id\n        self.num_loops = int(num_loops)\n        self.current_iteration = int(current_iteration)\n        self.is_finished = bool(is_finished)\n\n    def restart(self):\n        self.current_iteration = 0\n        self.is_finished = False\n\n    def step(self):\n        self.current_iteration += 1\n        if self.current_iteration > self.num_loops:\n            self.is_finished = True\n\n    def get_data(self):\n        return {\n            'node_id': self.node_id,\n            'num_loops': self.num_loops,\n            'current_iteration': self.current_iteration,\n            'is_finished': self.is_finished\n        }\n\n    @staticmethod\n    def from_data(node_id, data):\n        loop_data = LoopData(\n            node_id,\n            num_loops=data.get('num_loops', -1),\n            current_iteration=data.get('current_iteration', 0),\n            is_finished=data.get('is_finished', False)\n        )\n        return loop_data\n\n    def print(self, prefix=''):\n        print(F'{prefix}loop Data:', json.dumps(self.get_data(), indent=2))\n\n\n@flojoy\ndef LOOP(v, params):\n    num_loops = params.get('num_loops', 0)\n    node_id = params.get('node_id', 0)\n    \n    print('\\n\\nstart loop:', node_id)\n\n\n    # infinite loop\n    if num_loops == -1:\n        print('infinite loop')\n        return build_result(inputs=v, is_loop_finished=False)\n\n    loop_data: LoopData = load_loop_data(node_id, num_loops)\n    loop_data.print('at start ')\n\n    # loop was previously finished, but now re-executing, so restart\n    if loop_data.is_finished:\n        loop_data.restart()\n    else:\n        loop_data.step()\n\n    if not loop_data.is_finished:\n        store_loop_data(node_id, loop_data)\n    else:\n        print('finished loop')\n        delete_loop_data(node_id)\n\n    print('end loop\\n\\n')\n\n    return build_result(v, loop_data.is_finished)\n    \n\n\ndef load_loop_data(node_id, default_num_loops) -> LoopData:\n    data = SmallMemory().read_memory(node_id, memory_key)\n    loop_data = LoopData.from_data(\n        node_id=node_id,\n        data={'num_loops': default_num_loops, **data}\n    )\n    return loop_data\n\n\ndef store_loop_data(node_id, loop_data: LoopData):\n    SmallMemory().write_to_memory(node_id, memory_key, loop_data.get_data())\n    loop_data.print('store ')\n\ndef delete_loop_data(node_id):\n    SmallMemory().delete_object(node_id, memory_key)\n    print('delete loop data')\n\n\ndef build_result(inputs, is_loop_finished):\n    return JobResultBuilder() \\\n        .from_inputs(inputs) \\\n        .flow_by_flag(\n            flag=is_loop_finished,\n            directionsWhenFalse=['body'],\n            directionsWhenTrue=['end']) \\\n        .build()\n",
  "CONDITIONAL.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nfrom utils.utils import compare_values\n\n\n@flojoy\ndef CONDITIONAL(v, params):\n    operator = params['operator_type']\n\n    x = v[1].y\n    y = v[0].y\n    bool_ = compare_values(x[0], y[0], operator)\n    \n    data = None\n    if operator in [\"<=\", \"<\"]:\n        if not bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n    else:\n        if bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n\n    next_direction = str(bool_).lower()\n\n    return JobResultBuilder().from_data(data).flow_to_directions([next_direction]).build()"
}