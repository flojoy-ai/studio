{
  "template.py": "import plotly.graph_objects as go\n\n\ndef init_template():\n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n",
  "SURFACE3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SURFACE3D(dc_inputs, params):\n    dc_input = dc_inputs[0]\n    if dc_input.type == \"ordered_triple\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError(\"unsupported input type for SURFACE3D node\")\n    fig = go.Figure(data=go.Surface(x=x, y=y, z=z, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y, z=z)\n",
  "IMAGE.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\nimport numpy as np\n\n\n@flojoy\ndef IMAGE(dc_inputs, params):\n    dc_input = dc_inputs[0]\n    if dc_input.type == \"image\":\n        r = dc_input.r\n        g = dc_input.g\n        b = dc_input.b\n        a = dc_input.a\n    else:\n        raise ValueError(\"unsupported input type for IMAGE node\")\n    if a is None:\n        img_combined = np.stack((r, g, b), axis=2)\n    else:\n        img_combined = np.stack((r, g, b, a), axis=2)\n    fig = px.imshow(img=img_combined)\n\n    return DataContainer(type=\"plotly\", fig=fig, r=r, g=g, b=b, a=a)\n",
  "SCATTER.py": "import plotly.graph_objects as go\nfrom flojoy import flojoy, DataContainer\nimport pandas as pd\n\n\n@flojoy\ndef SCATTER(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"Node creates a Plotly Scatter visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Scatter(x=x, y=y, mode=\"markers\"))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                fig.add_trace(\n                    go.Scatter(x=df[col], y=df.index, mode=\"markers\", name=col)\n                )\n            fig.update_layout(\n                title=\"Scatter Plot\", xaxis_title=\"X Axis\", yaxis_title=\"Y Axis\"\n            )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for SCATTER node\")\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "LINE.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef LINE(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"Node creates a Plotly Line visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Line(x=x, y=y, mode=\"lines\"))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                fig.add_trace(go.Scatter(x=df.index, y=df[col], mode=\"lines\", name=col))\n                fig.update_layout(\n                    title=\"Line Plot\", xaxis_title=\"X Axis\", yaxis_title=\"Y Axis\"\n                )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for LINE node\")\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "TABLE.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef TABLE(dc_inputs: list[DataContainer], params: dict):\n    \"\"\"Node creates a Plotly table visualization for a given input data container.\n\n    Args:\n    dc_inputs (list): A list of DataContainer object(s) containing the input data.\n    params (dict): A dictionary containing the parameters needed for the visualization.\n\n    Returns:\n    DataContainer: A DataContainer object containing the generated visualization and the processed data.\n\n    Raises:\n    ValueError: If the input data container is not supported.\n    \"\"\"\n    dc_input = dc_inputs[0]\n    if dc_input.type in [\"dataframe\", \"plotly\"]:\n        df = pd.DataFrame(dc_input.m)\n        fig = go.Figure(\n            data=[\n                go.Table(\n                    header=dict(values=list(df.columns), align=\"left\"),\n                    cells=dict(values=[df[col] for col in df.columns], align=\"left\"),\n                )\n            ]\n        )\n        return DataContainer(type=\"plotly\", fig=fig, m=df)\n    else:\n        raise ValueError(\"unsupported DataContainer type for Plotly TABLE node\")\n",
  "SCATTER3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SCATTER3D(dc_inputs, params):\n    dc_input = dc_inputs[0]\n    if dc_input.type == \"ordered_triple\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError(\"unsupported input type for SCATTER3D node\")\n    fig = go.Figure(data=go.Scatter3d(x=x, y=y, z=z, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y, z=z)\n",
  "BAR.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef BAR(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"Node creates a Plotly Bar visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Bar(x=x, y=y))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                if df[col].dtype == \"object\":\n                    counts = df[col].value_counts()\n                    fig.add_trace(\n                        go.Bar(x=counts.index.tolist(), y=counts.tolist(), name=col)\n                    )\n                else:\n                    fig.add_trace(go.Bar(x=df.index, y=df[col], name=col))\n            fig.update_layout(\n                title=\"Bar Plot\", xaxis_title=\"X Axis\", yaxis_title=\"Y Axis\"\n            )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for BAR node\")\n\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "HISTOGRAM.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef HISTOGRAM(dc_inputs: list[DataContainer], params: dict):\n    \"\"\"Node creates a Plotly Histogram visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Histogram(x=x, y=y))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                fig.add_trace(go.Histogram(x=df[col], name=col))\n            fig.update_layout(\n                title=\"Histogram Plot\", xaxis_title=\"Value\", yaxis_title=\"Frequency\"\n            )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for HISTOGRAM node\")\n\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "OBJECT_DETECTION.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\n\nfrom utils.object_detection.object_detection import detect_object\n\n\n@flojoy\ndef OBJECT_DETECTION(dc_inputs, params):\n    try:\n        red_channel = []\n        green_channel = []\n        blue_channel = []\n        alpha_channel = []\n        print(\"Detecting objects...\")\n        r = dc_inputs[0].r\n        g = dc_inputs[0].g\n        b = dc_inputs[0].b\n        a = dc_inputs[0].a\n        print(\" a here: \", a)\n        if a is not None:\n            nparr = np.stack((r, g, b, a), axis=2)\n        else:\n            nparr = np.stack((r, g, b), axis=2)\n        img_array = detect_object(nparr)\n        if img_array.shape[2] == 4:\n            red_channel = img_array[:, :, 0]\n            green_channel = img_array[:, :, 1]\n            blue_channel = img_array[:, :, 2]\n            alpha_channel = img_array[:, :, 3]\n        else:\n            red_channel = img_array[:, :, 0]\n            green_channel = img_array[:, :, 1]\n            blue_channel = img_array[:, :, 2]\n            alpha_channel = None\n        return DataContainer(\n            type=\"image\",\n            r=red_channel,\n            g=green_channel,\n            b=blue_channel,\n            a=alpha_channel,\n        )\n\n    except Exception:\n        print(traceback.format_exc())\n        raise\n",
  "END.py": "from flojoy import flojoy, JobResultBuilder\n\n\n@flojoy\ndef END(dc_inputs, params):\n    inputs = dc_inputs if len(dc_inputs) > 0 else []\n    return JobResultBuilder().from_inputs(inputs).flow_to_nodes([]).build()\n",
  "CONDITIONAL.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nfrom utils.utils import compare_values\n\n\n@flojoy\ndef CONDITIONAL(dc_inputs, params):\n    operator = params[\"operator_type\"]\n\n    x = dc_inputs[1].y\n    y = dc_inputs[0].y\n    bool_ = compare_values(x[0], y[0], operator)\n\n    data = None\n    if operator in [\"<=\", \"<\"]:\n        if not bool_:\n            data = DataContainer(x=dc_inputs[0].x, y=y)\n        else:\n            data = DataContainer(x=dc_inputs[1].x, y=x)\n    else:\n        if bool_:\n            data = DataContainer(x=dc_inputs[0].x, y=y)\n        else:\n            data = DataContainer(x=dc_inputs[1].x, y=x)\n\n    next_direction = str(bool_).lower()\n\n    return (\n        JobResultBuilder().from_data(data).flow_to_directions([next_direction]).build()\n    )\n",
  "TIMER.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nimport time\n\n\n@flojoy\ndef TIMER(dc_inputs, params):\n    print(\"executing timer\")\n\n    seconds = int(params[\"sleep_time\"])\n    time.sleep(seconds)\n\n    return JobResultBuilder().from_inputs(dc_inputs).build()\n",
  "GOTO.py": "from flojoy import JobResultBuilder, flojoy\n\n\n@flojoy\ndef GOTO(dc_inputs, params):\n    goto_node_id = params.get(\"goto_node_id\", None)\n    next_nodes = [goto_node_id] if goto_node_id is not None else []\n\n    return JobResultBuilder().from_inputs(dc_inputs).flow_to_nodes(next_nodes).build()\n",
  "LOOP.py": "import json\n\nfrom node_sdk.small_memory import SmallMemory\n\nfrom flojoy import JobResultBuilder, flojoy\n\nmemory_key = \"loop-info\"\n\n\nclass LoopData:\n    def __init__(\n        self, node_id, num_loops=-1, current_iteration=0, is_finished=False\n    ) -> None:\n        self.node_id = node_id\n        self.num_loops = int(num_loops)\n        self.current_iteration = int(current_iteration)\n        self.is_finished = bool(is_finished)\n\n    def restart(self):\n        self.current_iteration = 0\n        self.is_finished = False\n\n    def step(self):\n        self.current_iteration += 1\n        if self.current_iteration > self.num_loops:\n            self.is_finished = True\n\n    def get_data(self):\n        return {\n            \"node_id\": self.node_id,\n            \"num_loops\": self.num_loops,\n            \"current_iteration\": self.current_iteration,\n            \"is_finished\": self.is_finished,\n        }\n\n    @staticmethod\n    def from_data(node_id, data):\n        loop_data = LoopData(\n            node_id,\n            num_loops=data.get(\"num_loops\", -1),\n            current_iteration=data.get(\"current_iteration\", 0),\n            is_finished=data.get(\"is_finished\", False),\n        )\n        return loop_data\n\n    def print(self, prefix=\"\"):\n        print(f\"{prefix}loop Data:\", json.dumps(self.get_data(), indent=2))\n\n\n@flojoy\ndef LOOP(dc_inputs, params):\n    num_loops = params.get(\"num_loops\", 0)\n    node_id = params.get(\"node_id\", 0)\n\n    print(\"\\n\\nstart loop:\", node_id)\n\n    # infinite loop\n    if num_loops == -1:\n        print(\"infinite loop\")\n        return build_result(inputs=dc_inputs, is_loop_finished=False)\n\n    loop_data: LoopData = load_loop_data(node_id, num_loops)\n    loop_data.print(\"at start \")\n\n    # loop was previously finished, but now re-executing, so restart\n    if loop_data.is_finished:\n        loop_data.restart()\n    else:\n        loop_data.step()\n\n    if not loop_data.is_finished:\n        store_loop_data(node_id, loop_data)\n    else:\n        print(\"finished loop\")\n        delete_loop_data(node_id)\n\n    print(\"end loop\\n\\n\")\n\n    return build_result(dc_inputs, loop_data.is_finished)\n\n\ndef load_loop_data(node_id, default_num_loops) -> LoopData:\n    data = SmallMemory().read_memory(node_id, memory_key)\n    loop_data = LoopData.from_data(\n        node_id=node_id, data={\"num_loops\": default_num_loops, **data}\n    )\n    return loop_data\n\n\ndef store_loop_data(node_id, loop_data: LoopData):\n    SmallMemory().write_to_memory(node_id, memory_key, loop_data.get_data())\n    loop_data.print(\"store \")\n\n\ndef delete_loop_data(node_id):\n    SmallMemory().delete_object(node_id, memory_key)\n    print(\"delete loop data\")\n\n\ndef build_result(inputs, is_loop_finished):\n    return (\n        JobResultBuilder()\n        .from_inputs(inputs)\n        .flow_by_flag(\n            flag=is_loop_finished,\n            directionsWhenFalse=[\"body\"],\n            directionsWhenTrue=[\"end\"],\n        )\n        .build()\n    )\n",
  "PHIDGET22.py": "from flojoy import flojoy, DataContainer\nimport Phidget22\nfrom Phidget22.Phidget import *\nfrom Phidget22.Devices.VoltageRatioInput import *\n\n\ndef onVoltageRatioChange(self, voltageRatio):\n    print(\n        \"VoltageRatio [\" + str(self.getChannel()) + \"]: \" + str(voltageRatio)\n    )  # Declaration of the Event handler, Voltage changement\n\n\n@flojoy\ndef PHIDGET22(dc, params):\n    voltage = []\n    pressions = []\n    N = int(params[\"n_sensors\"])\n\n    for i in range(0, N):\n        voltageRatioInput = (\n            VoltageRatioInput()\n        )  # Creation of an instance of the VoltageRationInput class\n        voltageRatioInput.setChannel(\n            i\n        )  # Set Channel for Communication with the Phidget Interface Kit\n        voltageRatioInput.setOnVoltageRatioChangeHandler(\n            onVoltageRatioChange\n        )  # Assign the handler that will be called when the event occurs\n        voltageRatioInput.openWaitForAttachment(\n            5000\n        )  # Open the Channel after event handler is set\n        volt_i = voltageRatioInput.getVoltageRatio()  # Measure Voltage from the sensor\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n\n        pression_i = (\n            volt_i - 0.015\n        ) / 0.06  # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n\n\n@flojoy\ndef PHIDGET22_MOCK(dc, params):\n    print(\n        \"running mock version of PHIDGET SENSOR, number of sensor is set to 4 by default\"\n    )\n\n    voltage = []\n    pressions = []\n    N = 4\n\n    for i in range(0, N):\n        volt_i = i * 10 + 4  # Scalar operation to modify data\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n        pression_i = (\n            volt_i - 0.015\n        ) / 0.06  # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n",
  "KEITHLEY2400.py": "import numpy as np\nimport serial\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef KEITHLEY2400(dc, params):  # params {comport, baudrate,timeout}\n    # Serial communication with the instrument configuration\n    ser = serial.Serial()\n\n    # Specific parameters\n\n    ser.port = params[\"comport\"]  # Secify serial port for com\n    ser.baudrate = params[\"baudrate\"]  # Specify Baudrate\n\n    # General parameters\n    ser.bytesize = serial.EIGHTBITS  # Specify Bites number\n    ser.parity = serial.PARITY_NONE  # Specify Parity\n    ser.stopbits = serial.STOPBITS_ONE  # Specify Stop bites\n    ser.timeout = 1\n    # Open Serial Com\n    ser.open()\n\n    # Keithley 2400 Configuration\n    ser.write(b\"*RST\\n\")  # reinitialisation of the instrument\n    ser.write(b\":SOUR:FUNC:MODE VOLT\\n\")  # Sourcing tension\n    ser.write(b':SENS:FUNC \"CURR\"\\n')  # Measuring current\n    ser.write(\n        b\":SENS:CURR:PROT 1.05\\n\"\n    )  # Current protection set at 1.05A : Maximum for keithely 2400\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        ser.write(b\":SOUR:VOLT %f\\n\" % voltage)  # Source Tension (V)\n        ser.write(b\":OUTP ON\\n\")  # Instrument output open\n        ser.write(b\":INIT\\n\")  # Start measuring\n        ser.write(b\":FETC?\\n\")  # Retrieve the measured values\n\n        current_str = ser.readline().decode(\"ascii\").strip()  # Save answers in a string\n        voltage_current_values = current_str.split(\n            \",\"\n        )  # Split the string into measured values (Voltage, Current, Etc)\n        currents_neg.append(\n            -float(voltage_current_values[1])\n        )  # Converts measured currents into float\n\n        ser.write(b\":OUTP OFF\\n\")  # Close output from Instrument\n\n    # Close Serial Communication\n\n    ser.close()\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n\n\n@flojoy\ndef KEITHLEY2400_MOCK(dc, params):  # params {comport, baudrate,timeout}\n    print(\"Running mock version of Keithley2400\")\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        voltage_current_values = (\n            voltages * 0.15\n        )  # Apply a scalar operation on the mock Voltage\n        currents_neg.append(\n            -float(voltage_current_values[1])\n        )  # Converts measured currents into float\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n",
  "CAMERA.py": "import cv2\nimport os\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef CAMERA(dc_inputs, params):\n    \"\"\"\n    Take a picture from a connected camera using OpenCV.\n    If no camera is connected, this will load the example image: \"object_detection.png\".\n    Perhaps after testing is finished, an error should be thrown if no camera was detected.\n    \"\"\"\n    print(\"parameters passed to CAMERA: \", params)\n    y = {}\n    camera_test = False  # Value to test if image is the default image.\n\n    try:\n        camera_index = int(params.get(\"camera_ind\", -1))\n        camera = cv2.VideoCapture(\n            camera_index\n        )  # Camera indicator for selection of specific camera\n        test = camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n        # print('\\n', test, '\\n')  # Print to check if setting the resolution worked.\n        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)\n\n        (\n            return_value,\n            image,\n        ) = camera.read()  # Read camera. Return value can be useful for testing.\n        if image is None:\n            raise cv2.error\n\n        # print(image.shape)\n        camera_test = True  # Camera has been detected.\n        camera.release()  # Release the camera for further use.\n        del camera\n\n    except (\n        cv2.error\n    ) as camera_error:  # Catch error for when a camera isn't detected. Should it throw an error for production?\n        pass\n\n    if not camera_test:\n        print(\"OpenCV cannot read the specified camera.\")\n        print(\"Loading backup image.\")\n        filePath = \"../public/assets/object_detection.png\"  # Load example image instead for testing.\n        # Load the file and put into bytearray.\n        print(\"File to be loaded: \" + filePath)\n        with open(filePath, \"rb\") as fileToBeLoaded:\n            f = fileToBeLoaded.read()\n            # print(type(cv2.imread(filePath)))\n            y = [bytearray(f)]\n            # print(type(f))\n            # print(type(bytearray(f)))\n        fileToBeLoaded.close()\n\n    else:\n        f = cv2.imencode(\".png\", image)[1]  # encode image to pass to next node.\n        y = [bytearray(f)]\n\n    return DataContainer(type=\"file\", y=y, file_type=[\"image\"])\n",
  "LABJACKU3.py": "from flojoy import flojoy, DataContainer\n\nimport u3  # Import the library from LabJackPython in order to use our U3-LV device\n\n\n@flojoy\ndef LABJACKU3(dc, params):  # params {nombre de sensor}\n    d = u3.U3()  # Create an instance of U3 class d.configU3()\n    d.configIO(\n        FIOAnalog=255, EIOAnalog=0\n    )  # Config the U3 for daq from temperature sensors\n\n    voltages = []  # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = int(params[\"numbers\"])\n\n    for i in range(1, N):  # Loop on the number of sensor you are using\n        voltage = d.getAIN(i - 1)\n        temperature = voltage * 100.0\n        temperature_celcius = (\n            temperature - 32\n        ) / 1.8  # Convert Voltage into temperature in Celcius\n\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n    return DataContainer(\n        x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius\n    )\n\n\n@flojoy\ndef LABJACKU3_MOCK(dc, params):  # params {nombre de sensor}\n    print(\"running mock version of LabJackU3, number of sensor is set to 6 by default\")\n\n    voltages = []  # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = 6  # Mock Number of sensors\n\n    for i in range(1, N):  # Loop on the number of sensor you are using\n        voltage = 0.6  # Mock Value for the measured voltage\n        temperature = voltage * 100.0\n        temperature_celcius = (\n            temperature - 32\n        ) / 1.8  # Convert Voltage into temperature in Celcius\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n\n    return DataContainer(\n        x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius\n    )\n",
  "SERIAL.py": "from flojoy import flojoy, DataContainer\nfrom time import sleep\nimport serial\nimport numpy as np\nfrom datetime import datetime\nimport plotly.graph_objects as go\n\n\n@flojoy\ndef SERIAL(dc_inputs, params):\n    \"\"\"\n    Node to take simple time dependent 1d data from an Ardunio,\n    or a similar serial device.\n    For example you can record temperature following this tutorial:\n\n    https://learn.adafruit.com/thermistor/using-a-thermistor\n\n    with Serial.println(steinhart) as the only line printing.\n\n    It is important that the last line Arduino is returning is the\n    data with a new line at the end (i.e. println()).\n\n    The other lines must be returned with print()\n    with print(\",\") between each line.\n\n    For example:\n\n    print(reading0)\n    print(\",\")\n    println(reading1)\n\n    If there is more than one column, the SELECT_ARRAY node must be\n    used after this node.\n\n    params:\n    num_readings: Number of points to record.\n    record_period: Length between two recordings in seconds.\n    BAUD_RATE: Baud rate for the serial device.\n    com_port: COM port of the serial device\n\n    num_readings * record_period is roughly the run length in seconds.\n    \"\"\"\n    print(\"parameters passed to SERIAL: \", params)\n    COM_PORT = params.get(\"com_port\", \"/dev/ttyUSB0\")\n    BAUD = int(params.get(\"BAUD_RATE\", 9600))\n    NUM = int(params.get(\"num_readings\", 100))\n    RECORD_PERIOD = float(params.get(\"record_period\", 1))\n\n    ser = serial.Serial(COM_PORT, timeout=1, baudrate=BAUD)\n    readings = []\n    times = []\n    # The first reading is commonly empty.\n    s = ser.readline().decode()\n\n    for i in range(NUM):\n        ts = datetime.now()\n        s = ser.readline().decode()\n        # Some readings may be empty.\n        if s != \"\":\n            reading = s[:-2].split(\",\")\n            readings.append(reading)\n\n            ts = datetime.now()\n            seconds = float(\n                ts.hour * 3600 + ts.minute * 60 + ts.second + ts.microsecond / 10**6\n            )\n\n            times.append(seconds)\n\n            if len(times) > 0:\n                time1 = seconds - times[i]\n            else:\n                # Estimate execution time.\n                time1 = 0.1\n\n            if time1 < RECORD_PERIOD:\n                sleep(RECORD_PERIOD - time1)\n\n    times = np.array(times)\n    times -= times[0]\n    readings = np.array(readings)\n    readings = readings.astype(\"float64\")\n    # If there are two or more columns return a Plotly figure.\n    if readings.ndim == 2:\n        data = go.Line(x=times, y=readings[:, 0], mode=\"markers\")\n        fig = go.Figure(data=data)\n        return DataContainer(type=\"plotly\", fig=fig, x=times, y=readings)\n    else:\n        return DataContainer(x=times, y=readings)\n\n\n@flojoy\ndef Serial_MOCK(dc, params):\n    print(\"Running mock version of Serial\")\n\n    x = np.linspace(0, 100, 100)\n    y = np.linspace(0, 100, 100)\n\n    return DataContainer(x=x, y=y)\n",
  "INVERT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef INVERT(dc_inputs, params):\n    \"\"\"Takes 2 inputs, one matrix and one rcond if not square matrix.\n    Inverts them (or pseudo invert) and returns the result.\n    If the entered value is a scalar it returns the multiplciative\n    inverse 1/x\"\"\"\n    print(f\"INVERT params: {params}\")\n    a = np.eye(3)\n    b = float(params[\"rcond\"])\n\n    if dc_inputs.__len__ > 0:\n        if (\n            dc_inputs[0].type == \"ordered_pair\"\n        ):  # v[0] is a DataContainer object with type attribute\n            print(\"Performing simple inversion\")\n            a = dc_inputs[0].y  # scalar valued\n            return DataContainer(x=a, y=1 / a)\n        elif dc_inputs[0].type == \"matrix\":\n            a = dc_inputs[0].m\n            if not a.shape[0] == a.shape[1]:\n                print(\"Not square matrix! Using pseudoinversion...\")\n                assert (\n                    type(b) == float\n                ), \"Need scalar value to compare SVDs for pseudoinversion\"\n                retval = np.linalg.pinv(a, rcond=b, hermitian=False)\n            else:\n                try:\n                    retval = np.linalg.inv(a)\n                except np.linalg.LinAlgError:\n                    raise ValueError(\"Inversion failed! Singular matrix returned...\")\n            return DataContainer(type=\"matrix\", m=retval)\n        else:\n            raise ValueError(\"Incorrect input DataContainer type.\")\n    else:\n        return DataContainer(type=\"matrix\", m=np.eye(3))\n",
  "MATMUL.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MATMUL(dc_inputs, params):\n    \"\"\"Takes 2 input matrices, multiplies them, and returns the result\"\"\"\n    a = np.eye(3)\n    b = np.eye(3)\n    if len(dc_inputs) == 2:\n        a = dc_inputs[0].y\n        b = dc_inputs[1][\"y\"]\n    return DataContainer(type=\"matrix\", m=np.matmul(a, b))\n",
  "SELECT_ARRAY.py": "from flojoy import flojoy, DataContainer\nimport numpy as np\n\n\n@flojoy\ndef SELECT_ARRAY(dc_inputs, params):\n    \"\"\"\n    Node to convert an input array with multiple columns\n    to the selected ordered pair.\n\n    For example, the SERIAL node can output x=time,\n    y1=temperature, y2=pressure.\n    This node will select one of temperature and pressure columns to output.\n\n    The x axis will be return unchanged.\n    \"\"\"\n    print(\"parameters passed to SELECT_ARRAY: \", params)\n    # Index of the selected column.\n    COL = int(params.get(\"column\", 0))\n\n    # Check for numpy type. Return unchanged data if not.\n    if isinstance(dc_inputs[0].y, np.ndarray):\n        x = dc_inputs[0].x\n        y = dc_inputs[0].y[:, int(COL)]\n\n        return DataContainer(x=x, y=y)\n\n    else:\n        return dc_inputs[0]\n",
  "SUBTRACT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef SUBTRACT(dc_inputs, params):\n    \"\"\"Subtract 2 input vectors and return the result\"\"\"\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(dc_inputs) == 2:\n        a = dc_inputs[0].y\n        b = dc_inputs[1][\"y\"]\n\n    y = np.subtract(a, b)\n\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "MULTIPLY.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MULTIPLY(dc_inputs, params):\n    \"\"\"Takes 2 input vectors, multiplies them, and returns the result\"\"\"\n    a = dc_inputs[0].y\n    b = dc_inputs[1].y\n    y = np.multiply(a, b)\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "ADD.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef ADD(dc_inputs: list[DataContainer], params: dict):\n    \"\"\"Add 2 or more numeric arrays, matrices, dataframes, or constants element-wise.\n    When a constant is added to an array or matrix, each element in the array or\n    matrix will be increased by the constant value. If 2 arrays or matrices of different\n    sizes are added, the output will be the size of the larger array or matrix with\n    only the overlapping elements changed.\n    \"\"\"\n\n    if len(dc_inputs) < 2:\n        raise ValueError(\n            f\"To add the values, ADD node requires two inputs, {len(dc_inputs)} was given!\"\n        )\n    a = dc_inputs[0].y\n    b = dc_inputs[1].y\n\n    y = np.add(a, b)\n\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "ABS.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef ABS(dc_inputs, params):\n    \"\"\"Returns abolute value\"\"\"\n    return DataContainer(x=dc_inputs[0].y, y=np.abs(dc_inputs[0].y))\n",
  "FIR.py": "from scipy import signal\nfrom flojoy import flojoy, DataContainer\nimport numpy as np\n\n\n@flojoy\ndef FIR(dc_inputs, params):\n    \"\"\"Apply a low-pass FIR filter to an input vector. This\n    filter takes a few inputs: the sample_rate (will be passed as a parameter\n    if the target node is not connected), the desired width of the\n    transition to the stop band and the corresponding attentuation, and\n    lastly the cutoff frequency.\"\"\"\n\n    sample_rate = float(params[\"sample_rate\"])  # Hz\n    transition_width = float(params[\"transition_width\"])  # Hz\n    stop_band_attenuation = float(params[\"stop_band_attenuation\"])  # dB\n    cutoff_freq = float(params[\"cutoff_freq\"])  # Hz\n    print(\n        f\"FIR params: {[sample_rate,transition_width,stop_band_attenuation,cutoff_freq]}\"\n    )\n\n    try:\n        times = dc_inputs[1].y  # v[0].x['i']\n        x = dc_inputs[0].y  # this is the value of the signal\n    except IndexError:  # nothing input\n        # lets create some default behaviour for testing\n        nsamples = 400\n        times = np.arange(nsamples) / sample_rate\n        test_x = (\n            np.cos(2 * np.pi * 0.5 * times)\n            + 0.2 * np.sin(2 * np.pi * 2.5 * times + 0.1)\n            + 0.2 * np.sin(2 * np.pi * 15.3 * times)\n            + 0.1 * np.sin(2 * np.pi * 16.7 * times + 0.1)\n            + 0.1 * np.sin(2 * np.pi * 23.45 * times + 0.8)\n        )\n        x = test_x\n\n    # first we need to define the nyquist rate ...\n    nyq_rate = sample_rate / 2.0\n    # ... then the transition width relative to this\n    transition_width /= nyq_rate\n\n    # Now compute order and Kaiser param for the fitler\n    N, beta = signal.kaiserord(stop_band_attenuation, transition_width)\n\n    # Now we create the filter with the Kaiser window ...\n    taps = signal.firwin(N, cutoff_freq / nyq_rate, window=(\"kaiser\", beta))\n\n    # ... and then apply it to the signal\n    filtered_x = signal.lfilter(taps, 1.0, x)\n\n    # Now, there are two considerations to be had. Firstly,\n    # there is a phase delay in the signal since we have applied finite\n    # taps ...\n    phase_delay = 0.5 * (N - 1) / sample_rate\n    # ... and furthermore, the first N-1 samples are 'corrupted' in\n    # the sense that the filter 'sacrifies' them by the imposition\n    # of the initial conditions.\n    times = times[N - 1 :] - phase_delay\n    filtered_x = filtered_x[N - 1 :]\n\n    return DataContainer(x=times, y=filtered_x)\n",
  "PID.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = \"pid-info\"\n\n\n@flojoy\ndef PID(dc_inputs, params):\n    # First let's get the parameters that won't change\n    Kp = float(params[\"Kp\"])\n    Ki = float(params[\"Ki\"])\n    Kd = float(params[\"Kd\"])\n    node_id = params.get(\"node_id\", 0)\n    # Now we need some memory! We need to keep track of the running\n    # integral value of the inputs (regulation errors), as well as\n    # the previous 3 values of the regulation error\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Issue reading memory from REDIS.\")\n    integral = 0 if initialize else data[0]\n    regulation_error_primes = np.zeros((3, 1)) if initialize else data[1:]\n    print(f\"Recovered data: {data}\")\n\n    regulation_error = dc_inputs[0].y[\n        -1\n    ]  # constant node makes long list of items; just need the value so take last element\n    integral += 0.5 * Ki * (regulation_error + regulation_error_primes[0])\n    output_signal = (\n        Kp * regulation_error\n        + integral\n        + 0.1667\n        * Kd\n        * (\n            regulation_error\n            - regulation_error_primes[2]\n            + 3.0 * (regulation_error_primes[0] - regulation_error_primes[1])\n        )\n    )\n    regulation_error_primes[2] = regulation_error_primes[1]\n    regulation_error_primes[1] = regulation_error_primes[0]\n    regulation_error_primes[0] = regulation_error\n\n    # Now write to memory ...\n    SmallMemory().write_to_memory(\n        node_id, memory_key, np.append(integral, regulation_error_primes)\n    )\n    print(regulation_error, output_signal)\n    # ... and return the result\n    return DataContainer(\n        x=dc_inputs[0].y, y=np.ones_like(dc_inputs[0].y) * output_signal\n    )\n",
  "BUTTER.py": "from scipy import signal\nimport numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef BUTTER(dc_inputs, params):\n    \"\"\"Apply a butterworth filter to an input vector\"\"\"\n\n    print(\"Butterworth inputs:\", dc_inputs)\n\n    sig = dc_inputs[0].y\n\n    sos = signal.butter(10, 15, \"hp\", fs=1000, output=\"sos\")\n    filtered = signal.sosfilt(sos, sig)\n\n    return DataContainer(x=sig, y=filtered)\n",
  "SAVGOL.py": "import scipy\nfrom flojoy import flojoy, DataContainer\nimport warnings\n\n\n@flojoy\ndef SAVGOL(dc_inputs, params):\n    \"\"\"Apply a Savitzky-Golay filter to an input vector.\n    The default behaviour is implementing a 3-point moving average of the data.\"\"\"\n    print(\"Savgol inputs:\", dc_inputs)\n    signal = dc_inputs[0].y\n    window_length = int(params[\"wlen\"])\n    poly_order = int(params[\"porder\"])\n    if poly_order >= window_length:\n        warnings.warn(\n            \"Polynomial order is greater than the window size. Using p=w-1...\"\n        )\n        poly_order = window_length - 1\n    filtered = scipy.signal.savgol_filter(signal, window_length, poly_order)\n    return DataContainer(x=signal, y=filtered)\n",
  "PLOTLY_DATASET.py": "from flojoy import flojoy, DataContainer\nfrom plotly.express import data\n\n\n@flojoy\ndef PLOTLY_DATASET(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    dataset_key = params[\"dataset_key\"]\n    df = getattr(data, dataset_key)()\n\n    return DataContainer(type=\"dataframe\", m=df)\n",
  "R_DATASET.py": "from flojoy import flojoy, DataContainer\nfrom rdatasets import data\n\n\n@flojoy\ndef R_DATASET(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"\n    Retrieves a pandas DataFrame from rdatasets using the provided dataset_key parameter and returns it wrapped in a DataContainer.\n\n    Args:\n        dc_inputs (list[DataContainer]): A list of DataContainer objects, but not used in this function.\n        params (dict): A dictionary of parameters for this function.\n            dataset_key (str): The key used to retrieve the DataFrame.\n\n    Returns:\n        DataContainer: A DataContainer object containing the retrieved pandas DataFrame.\n    \"\"\"\n    dataset_key = params[\"dataset_key\"]\n    df = data(dataset_key)\n    return DataContainer(type=\"dataframe\", m=df)\n",
  "SKLEARNIMAGE.py": "from flojoy import flojoy, DataContainer\nfrom skimage import data\n\n\n@flojoy\ndef SKLEARNIMAGE(dc_inputs, params):\n    \"\"\"Node designed to load example images from scikit-image.\n\n    Examples can be found here:\n    https://scikit-image.org/docs/stable/auto_examples/index.html\n\n    \"\"\"\n    img_key = params[\"img_key\"]\n\n    img_array = getattr(data, img_key)()\n\n    if len(img_array.shape) == 2:\n        red = green = blue = img_array\n        alpha = None\n    elif len(img_array.shape) == 3:\n        # Color image\n        if img_array.shape[2] == 3:\n            red, green, blue = (\n                img_array[:, :, 0],\n                img_array[:, :, 1],\n                img_array[:, :, 2],\n            )\n            alpha = None\n        elif img_array.shape[2] == 4:\n            red, green, blue, alpha = (\n                img_array[:, :, 0],\n                img_array[:, :, 1],\n                img_array[:, :, 2],\n                img_array[:, :, 3],\n            )\n\n    return DataContainer(\n        type=\"image\",\n        r=red,\n        g=green,\n        b=blue,\n        a=alpha,\n    )\n",
  "TIMESERIES.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport pandas.testing as testing\nimport traceback\n\n\n@flojoy\ndef TIMESERIES(dc_inputs, params):\n    \"\"\"\n    Generates a random timeseries vector\n    \"\"\"\n\n    try:\n        np.random.seed(1)\n        testing.N, testing.K = 1000, 1  # rows, columns\n        df = testing.makeTimeDataFrame(freq=\"MS\")\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(x=df.index.to_numpy(), y=df[\"A\"].to_numpy())\n",
  "SINE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom scipy import signal\n\n\n@flojoy\ndef SINE(dc_inputs, params):\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n    x = None\n    if dc_inputs.__len__() > 0:\n        x = dc_inputs[0].y\n\n    waveform = params[\"waveform\"]\n    A = float(params[\"amplitude\"])\n    F = float(params[\"frequency\"])\n    Y0 = float(params[\"offset\"])\n    PHASE = float(params[\"phase\"])\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print(\"invalid waveform passed as param, using default:\", waveform)\n\n    if waveform == \"sine\":\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x + np.radians(PHASE))\n    elif waveform == \"square\":\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10 + np.radians(PHASE))\n    elif waveform == \"triangle\":\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10 + np.radians(PHASE), 0.5)\n    elif waveform == \"sawtooth\":\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x + np.radians(PHASE))\n\n    return DataContainer(x=x, y=y)\n",
  "FEEDBACK.py": "from flojoy import flojoy, DataContainer, get_job_result\nfrom rq.job import NoSuchJobError\nimport traceback\n\n\n@flojoy\ndef FEEDBACK(dc_inputs, params):\n    referred_node = params[\"referred_node\"]\n\n    try:\n        result = get_job_result(referred_node)\n        return result\n    except (Exception, NoSuchJobError) as e:\n        x = dc_inputs[0].x\n        y = dc_inputs[0].y\n        print(\"Job not found: \", e, traceback.format_exc())\n        return DataContainer(x=x, y=y)\n",
  "CONSTANT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef CONSTANT(dc_inputs, params):\n    \"\"\"Generates a single x-y vector of numeric (floating point) constants\"\"\"\n\n    if dc_inputs.__len__() > 0:\n        x = dc_inputs[0].y\n        y = np.full(len(x), float(params[\"constant\"]))\n        return DataContainer(x=x, y=y)\n\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params[\"constant\"]))\n\n    return DataContainer(x=x, y=y)\n",
  "RAND.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport traceback\n\n\n@flojoy\ndef RAND(dc_inputs, params):\n    x = None\n    if len(dc_inputs) > 0:\n        x = dc_inputs[0].y\n        y = np.random.normal(size=len(x))\n    else:\n        y = np.random.normal(size=1000)\n\n    return DataContainer(x=x, y=y)\n\n\n@flojoy\ndef RAND_MOCK(dc_inputs, params):\n    print(\"running mock version of rand\")\n    x = None\n    if len(dc_inputs) > 0:\n        x = dc_inputs[0].y\n        y = x\n    else:\n        y = np.full(\n            1000, 1000\n        )  # for reproducibility returning an array with constant values\n    return DataContainer(x=x, y=y)\n",
  "SECOND_ORDER_SYSTEM.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = \"SECOND_ORDER_SYSTEM\"\n\n\n@flojoy\ndef SECOND_ORDER_SYSTEM(dc_inputs, params):\n    # Let's first define things that won't change over\n    # each iteration: time constants, etc ...\n    d1 = float(params[\"d1\"])  # first time constant in us, 250\n    d2 = float(params[\"d2\"])  # second time constant in us, 100\n    node_id = params.get(\"node_id\", 0)\n\n    # ... and now some helper functions\n    x1 = np.exp(-1.0 / d1) if d1 > 0 else 0.0\n    x2 = np.exp(-1.0 / d2) if d2 > 0 else 0.0\n    ac = (1.0 - x1) * (1.0 - x2)\n    bpd = x1 + x2\n    bd = x1 * x2\n\n    # Now we require memory. The only thing we need in memory is the last two\n    # values the system had in this basic example.\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Error loading object from REDIS.\")\n\n    # We're going to store and read the data in reverse order to\n    # how it is accessed here. We will write the functionality\n    # below to assume the most recent time step is the first\n    # index. However, for visualization and external access,\n    # it makes the most sense to have the first time step\n    # as the first index!\n    y_primes = np.zeros((2, 1)) if initialize else data[::-1]\n\n    # Using input from controller as v[0].y ...\n    response = ac * dc_inputs[0].y[-1] + bpd * y_primes[0] - bd * y_primes[1]\n    y_primes[1] = y_primes[0]\n\n    # prepend the most recent result to the front of the histrory\n    y_primes = np.insert(y_primes, 0, response)\n    # We now write to memory, reversing the order ...\n    SmallMemory().write_to_memory(node_id, memory_key, y_primes[::-1])\n    # ... and return the result!\n    return DataContainer(\n        x=dc_inputs[0].y, y=np.ones_like(dc_inputs[0].y) * float(y_primes[0])\n    )  # returns input output pair\n",
  "LINSPACE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef LINSPACE(dc_inputs, params):\n    x = None\n    if dc_inputs.__len__() > 0:\n        x = dc_inputs[0].y\n    y = np.linspace(float(params[\"start\"]), float(params[\"end\"]), int(params[\"step\"]))\n    result = DataContainer(x=x, y=y)\n    return result\n",
  "LOCAL_FILE.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\nfrom PIL import Image\nfrom os import path\n\n\n@flojoy\ndef LOCAL_FILE(dc_inputs, params):\n    print(\"parameters passed to LOCAL_FILE: \", params)\n    file_type = params[\"file_type\"]\n    match file_type:\n        case \"image\":\n            red_channel = []\n            green_channel = []\n            blue_channel = []\n            alpha_channel = []\n            try:\n                default_image_path = path.join(\n                    path.dirname(path.abspath(__file__)),\n                    \"assets\",\n                    \"astronaut.png\",\n                )\n                filePath = params[\"path\"]\n                if filePath == \"\":\n                    filePath = default_image_path\n                print(\" file will be loaded from: \", filePath)\n                f = Image.open(filePath)\n                img_array = np.array(f.convert(\"RGBA\"))\n                if img_array.shape[2] == 4:\n                    red_channel = img_array[:, :, 0]\n                    green_channel = img_array[:, :, 1]\n                    blue_channel = img_array[:, :, 2]\n                    alpha_channel = img_array[:, :, 3]\n                else:\n                    red_channel = img_array[:, :, 0]\n                    green_channel = img_array[:, :, 1]\n                    blue_channel = img_array[:, :, 2]\n                    alpha_channel = None\n            except Exception:\n                print(traceback.format_exc())\n            return DataContainer(\n                type=\"image\",\n                r=red_channel,\n                g=green_channel,\n                b=blue_channel,\n                a=alpha_channel,\n            )\n        case _:\n            return JobResultBuilder().from_inputs(dc_inputs).build()\n",
  "LOADER.py": "import json\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport requests\nimport yaml\nfrom flojoy import DataContainer, flojoy\nfrom flojoy.utils import PlotlyJSONEncoder\n\nFRONTIER_URI = (\n    os.environ.get(\"FRONTIER_URI\")\n    or \"https://cipfsgeml2.execute-api.us-east-1.amazonaws.com\"\n)\nMEASUREMENT_API = f\"{FRONTIER_URI}/measurements\"\n\n\n@flojoy\ndef LOADER(dc_inputs: list[DataContainer], params: dict):\n    api_key = get_api_key()\n    measurement_uuid = params[\"measurement_uuid\"]\n\n    if api_key != \"\" and measurement_uuid != \"\":\n        try:\n            requests.post(\n                f\"{MEASUREMENT_API}/{measurement_uuid}\",\n                json={\n                    \"api_key\": api_key,\n                    \"measurements\": json.dumps(\n                        {\"data\": dc_inputs[0]}, cls=PlotlyJSONEncoder\n                    ),\n                    \"time\": datetime.now().__str__(),\n                },\n            )\n        except Exception as e:\n            raise e\n        return dc_inputs[0]\n    else:\n        not_found_key = \"FRONTIER_API_KEY\" if api_key == \"\" else \"Measurement UUID\"\n        raise KeyError(f\"{not_found_key} not found!\")\n\n\ndef get_api_key():\n    home = str(Path.home())\n    api_key = \"\"\n    path = os.path.join(home, \".flojoy/credentials\")\n    if not os.path.exists(path):\n        return api_key\n\n    stream = open(path, \"r\", encoding=\"utf-8\")\n    yaml_dict = yaml.load(stream, Loader=yaml.FullLoader)\n    if yaml_dict is None:\n        return api_key\n    if isinstance(yaml_dict, str) == True:\n        split_by_line = yaml_dict.split(\"\\n\")\n        for line in split_by_line:\n            if \"FRONTIER_API_KEY\" in line:\n                api_key = line.split(\":\")[1]\n    else:\n        api_key = yaml_dict.get(\"FRONTIER_API_KEY\", \"\")\n    return api_key\n\ndef set_api_key(api:str) -> bool:\n    home = str(Path.home())\n    path = os.path.join(home, \".flojoy/credentials\")\n    if not os.path.exists(path):\n        return False\n    stream = open(path, \"r\", encoding=\"utf-8\")\n    yaml_dict = yaml.load(stream, Loader=yaml.FullLoader)\n    yaml_dict.put(\"FRONTIER_API_KEY\", api)\n    return True\n"
}
